//! Code generation for yogurt subgraphs.
//!
//! This crate reads `subgraph.yaml`, `schema.graphql`, and ABI JSON files
//! to generate type-safe Rust code.

mod abi;
mod error;
mod manifest;
mod schema;

pub use abi::AbiParser;
pub use error::{CodegenError, Result};
pub use manifest::{DataSource, Manifest};
pub use schema::SchemaParser;

use sha2::{Sha256, Digest};
use std::fs;
use std::path::Path;

const HASH_FILE_NAME: &str = ".codegen-hash";

/// Generate all Rust code for a subgraph.
pub fn generate(manifest_path: &Path, output_dir: &Path) -> Result<()> {
    // Read and parse the manifest
    let manifest_content = fs::read_to_string(manifest_path)?;
    let manifest = Manifest::parse(&manifest_content)?;

    // Ensure output directory exists
    fs::create_dir_all(output_dir)?;

    // Parse schema and generate entity types
    if let Some(schema_path) = manifest_path.parent().map(|p| p.join(&manifest.schema.file))
    {
        let schema_content = fs::read_to_string(&schema_path)?;
        let schema = SchemaParser::parse(&schema_content)?;
        let schema_code = schema.generate_rust();
        fs::write(output_dir.join("schema.rs"), schema_code)?;
    }

    // Parse ABIs and generate event/contract types
    let mut abi_modules = Vec::new();

    for data_source in &manifest.data_sources {
        // Collect call handler function names for this data source
        let call_handler_functions: Vec<String> = data_source
            .mapping
            .call_handlers
            .iter()
            .map(|ch| extract_function_name(&ch.function))
            .collect();

        for abi in &data_source.mapping.abis {
            if let Some(abi_path) = manifest_path.parent().map(|p| p.join(&abi.file)) {
                let abi_content = fs::read_to_string(&abi_path)?;
                let parsed_abi = AbiParser::parse(&abi_content)?;
                let module_name = abi.name.to_lowercase();

                // Convert to &str slice for the API
                let func_refs: Vec<&str> = call_handler_functions
                    .iter()
                    .map(|s| s.as_str())
                    .collect();

                let abi_code = parsed_abi.generate_rust_with_call_handlers(&abi.name, &func_refs);
                fs::write(output_dir.join(format!("{}.rs", module_name)), abi_code)?;
                abi_modules.push(module_name);
            }
        }
    }

    // Generate templates if any exist
    let has_templates = !manifest.templates.is_empty();
    if has_templates {
        let templates_code = generate_templates(&manifest.templates);
        fs::write(output_dir.join("templates.rs"), templates_code)?;
    }

    // Generate mod.rs
    let mod_code = generate_mod_rs(&abi_modules, has_templates);
    fs::write(output_dir.join("mod.rs"), mod_code)?;

    // Store hash of inputs for freshness checking
    store_codegen_hash(manifest_path, output_dir)?;

    Ok(())
}

fn generate_mod_rs(abi_modules: &[String], has_templates: bool) -> String {
    let mut code = String::from(
        "//! Auto-generated by yogurt codegen — do not edit\n\n\
         mod schema;\n",
    );

    for module in abi_modules {
        code.push_str(&format!("mod {};\n", module));
    }

    if has_templates {
        code.push_str("pub mod templates;\n");
    }

    code.push_str("\npub use schema::*;\n");

    for module in abi_modules {
        code.push_str(&format!("pub use {}::*;\n", module));
    }

    code
}

/// Generate the templates module with data source template types.
fn generate_templates(templates: &[manifest::DataSourceTemplate]) -> String {
    let mut code = String::from(
        "//! Auto-generated data source templates — do not edit\n\n\
         use alloc::string::ToString;\n\
         use yogurt_runtime::prelude::Address;\n\
         use yogurt_runtime::data_source;\n\n",
    );

    for template in templates {
        let struct_name = to_pascal_case(&template.name);
        let is_file_ds = template.kind.starts_with("file/");

        code.push_str(&format!(
            "/// Data source template: `{name}`\n\
             ///\n\
             /// Kind: `{kind}`\n\
             pub struct {struct_name};\n\n\
             impl {struct_name} {{\n",
            name = template.name,
            kind = template.kind,
            struct_name = struct_name,
        ));

        if is_file_ds {
            // File data sources take a single string param (content ID)
            code.push_str(&format!(
                "    /// Create a new file data source for the given content identifier.\n\
                 ///\n\
                 /// For IPFS: pass the CID (e.g., \"QmXxx...\")\n\
                 /// For Arweave: pass the transaction ID\n\
                 pub fn create(content_id: &str) {{\n\
                     data_source::create(\"{name}\", &[content_id.to_string()]);\n\
                 }}\n",
                name = template.name,
            ));
        } else {
            // Ethereum contract templates take an address
            code.push_str(&format!(
                "    /// Create a new data source instance for the given contract address.\n\
                 pub fn create(address: &Address) {{\n\
                     data_source::create(\"{name}\", &[address.to_hex()]);\n\
                 }}\n",
                name = template.name,
            ));
        }

        code.push_str("}\n\n");
    }

    code
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == ' ' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Compute a hash of all codegen inputs (manifest, schema, ABIs).
///
/// This hash is used to determine if codegen needs to be re-run.
pub fn compute_codegen_hash(manifest_path: &Path) -> Result<String> {
    let mut hasher = Sha256::new();

    // Hash the manifest itself
    let manifest_content = fs::read_to_string(manifest_path)?;
    hasher.update(manifest_content.as_bytes());

    let manifest = Manifest::parse(&manifest_content)?;

    // Hash the schema file
    if let Some(schema_path) = manifest_path.parent().map(|p| p.join(&manifest.schema.file)) {
        if schema_path.exists() {
            hasher.update(fs::read(&schema_path)?);
        }
    }

    // Hash all ABI files
    for data_source in &manifest.data_sources {
        for abi in &data_source.mapping.abis {
            if let Some(abi_path) = manifest_path.parent().map(|p| p.join(&abi.file)) {
                if abi_path.exists() {
                    hasher.update(fs::read(&abi_path)?);
                }
            }
        }
    }

    // Include yogurt version to invalidate cache on toolchain updates
    hasher.update(env!("CARGO_PKG_VERSION").as_bytes());

    Ok(format!("{:x}", hasher.finalize()))
}

/// Check if the generated code is up to date.
///
/// Returns `true` if the hash of current inputs matches the stored hash,
/// meaning codegen can be skipped.
pub fn is_codegen_fresh(manifest_path: &Path, output_dir: &Path) -> Result<bool> {
    let hash_file = output_dir.join(HASH_FILE_NAME);

    if !hash_file.exists() {
        return Ok(false);
    }

    let stored_hash = fs::read_to_string(&hash_file)?;
    let current_hash = compute_codegen_hash(manifest_path)?;

    Ok(stored_hash.trim() == current_hash)
}

/// Store the codegen hash after successful generation.
fn store_codegen_hash(manifest_path: &Path, output_dir: &Path) -> Result<()> {
    let hash = compute_codegen_hash(manifest_path)?;
    let hash_file = output_dir.join(HASH_FILE_NAME);
    fs::write(hash_file, hash)?;
    Ok(())
}

/// Extract the function name from a function signature.
///
/// e.g., "mint(uint256)" -> "mint"
///       "transfer(address,uint256)" -> "transfer"
fn extract_function_name(signature: &str) -> String {
    signature
        .split('(')
        .next()
        .unwrap_or(signature)
        .to_string()
}
