//! GraphQL schema parsing and Rust code generation.

use crate::error::{CodegenError, Result};

/// A parsed GraphQL schema.
#[derive(Debug)]
pub struct SchemaParser {
    pub entities: Vec<Entity>,
}

/// A GraphQL entity type.
#[derive(Debug)]
pub struct Entity {
    pub name: String,
    pub fields: Vec<Field>,
    pub is_immutable: bool,
}

/// A field in a GraphQL entity.
#[derive(Debug)]
pub struct Field {
    pub name: String,
    pub field_type: FieldType,
    pub is_required: bool,
    pub is_derived: bool,
    pub derived_from: Option<String>,
}

/// GraphQL field types.
#[derive(Debug, Clone)]
pub enum FieldType {
    Id,
    String,
    Int,
    Int8,
    BigInt,
    BigDecimal,
    Bytes,
    Boolean,
    Array(Box<FieldType>),
    Reference(String),
}

impl SchemaParser {
    /// Parse a GraphQL schema from content.
    pub fn parse(content: &str) -> Result<Self> {
        use graphql_parser::schema::{parse_schema, Definition, TypeDefinition};

        let doc = parse_schema::<String>(content)
            .map_err(|e| CodegenError::GraphQL(e.to_string()))?;

        let mut entities = Vec::new();

        for def in doc.definitions {
            if let Definition::TypeDefinition(TypeDefinition::Object(obj)) = def {
                // Check for @entity directive
                let is_entity = obj.directives.iter().any(|d| d.name == "entity");
                if !is_entity {
                    continue;
                }

                // Check for @entity(immutable: true)
                let is_immutable = obj.directives.iter().any(|d| {
                    d.name == "entity"
                        && d.arguments.iter().any(|(k, v)| {
                            k == "immutable" && matches!(v, graphql_parser::schema::Value::Boolean(true))
                        })
                });

                let mut fields = Vec::new();

                for field in &obj.fields {
                    // Check for @derivedFrom directive
                    let derived_from = field
                        .directives
                        .iter()
                        .find(|d| d.name == "derivedFrom")
                        .and_then(|d| {
                            d.arguments.iter().find(|(k, _)| k == "field").map(|(_, v)| {
                                if let graphql_parser::schema::Value::String(s) = v {
                                    s.clone()
                                } else {
                                    String::new()
                                }
                            })
                        });

                    let is_derived = derived_from.is_some();

                    let (field_type, is_required) = parse_field_type(&field.field_type)?;

                    fields.push(Field {
                        name: field.name.clone(),
                        field_type,
                        is_required,
                        is_derived,
                        derived_from,
                    });
                }

                entities.push(Entity {
                    name: obj.name.clone(),
                    fields,
                    is_immutable,
                });
            }
        }

        Ok(SchemaParser { entities })
    }

    /// Generate Rust code for all entities.
    pub fn generate_rust(&self) -> String {
        let mut code = String::from(
            "//! Auto-generated by yogurt codegen — do not edit\n\n\
             #[allow(unused_imports)]\n\
             use alloc::string::String;\n\
             #[allow(unused_imports)]\n\
             use alloc::vec::Vec;\n\
             use yogurt_runtime::prelude::*;\n\
             use yogurt_runtime::store;\n\
             use yogurt_runtime::types::{EntityData, Value};\n\n",
        );

        for entity in &self.entities {
            code.push_str(&generate_entity_struct(entity));
            code.push('\n');
        }

        code
    }
}

fn parse_field_type(
    ty: &graphql_parser::schema::Type<String>,
) -> Result<(FieldType, bool)> {
    use graphql_parser::schema::Type;

    match ty {
        Type::NonNullType(inner) => {
            let (ft, _) = parse_field_type(inner)?;
            Ok((ft, true))
        }
        Type::ListType(inner) => {
            let (ft, _) = parse_field_type(inner)?;
            Ok((FieldType::Array(Box::new(ft)), false))
        }
        Type::NamedType(name) => {
            let ft = match name.as_str() {
                "ID" => FieldType::Id,
                "String" => FieldType::String,
                "Int" => FieldType::Int,
                "Int8" => FieldType::Int8,
                "BigInt" => FieldType::BigInt,
                "BigDecimal" => FieldType::BigDecimal,
                "Bytes" => FieldType::Bytes,
                "Boolean" => FieldType::Boolean,
                other => FieldType::Reference(other.to_string()),
            };
            Ok((ft, false))
        }
    }
}

fn generate_entity_struct(entity: &Entity) -> String {
    let name = &entity.name;

    // Add doc comment for immutable entities
    let mut code = if entity.is_immutable {
        format!(
            "/// Immutable entity — setters are not generated.\n\
             pub struct {} {{\n    data: EntityData,\n}}\n\n",
            name
        )
    } else {
        format!(
            "pub struct {} {{\n    data: EntityData,\n}}\n\n",
            name
        )
    };

    // Constructor
    code.push_str(&format!(
        "impl {name} {{\n\
            pub fn new(id: impl Into<String>) -> Self {{\n\
                let mut data = EntityData::new();\n\
                data.set(\"id\", Value::String(id.into()));\n\
                Self {{ data }}\n\
            }}\n\n",
        name = name
    ));

    // Getters
    for field in &entity.fields {
        if field.is_derived {
            continue; // Skip derived fields
        }

        let getter = generate_getter(field);
        code.push_str(&getter);
    }

    // Setters (skip for immutable entities)
    if !entity.is_immutable {
        for field in &entity.fields {
            if field.is_derived || field.name == "id" {
                continue; // Skip derived fields and id
            }

            let setter = generate_setter(field);
            code.push_str(&setter);
        }
    }

    code.push_str("}\n\n");

    // Entity trait implementation
    code.push_str(&format!(
        "impl Entity for {name} {{\n\
            const ENTITY_TYPE: &'static str = \"{name}\";\n\n\
            fn id(&self) -> &str {{\n\
                self.data.get_string(\"id\")\n\
            }}\n\n\
            fn save(&self) {{\n\
                store::set(Self::ENTITY_TYPE, self.id(), &self.data);\n\
            }}\n\n\
            fn load(id: &str) -> Option<Self> {{\n\
                store::get(Self::ENTITY_TYPE, id).map(|data| Self {{ data }})\n\
            }}\n\n\
            fn remove(id: &str) {{\n\
                store::remove(Self::ENTITY_TYPE, id);\n\
            }}\n\
        }}\n",
        name = name
    ));

    code
}

fn generate_getter(field: &Field) -> String {
    let name = &field.name;
    let method_name = to_snake_case(name);

    let (return_type, getter_body) = match &field.field_type {
        FieldType::Id | FieldType::String => {
            if field.is_required {
                ("&str".to_string(), format!("self.data.get_string(\"{}\")", name))
            } else {
                ("Option<&str>".to_string(), format!("self.data.get_string_opt(\"{}\")", name))
            }
        }
        FieldType::Int => {
            if field.is_required {
                (
                    "i32".to_string(),
                    format!("self.data.get_int_opt(\"{}\").unwrap_or(0)", name),
                )
            } else {
                (
                    "Option<i32>".to_string(),
                    format!("self.data.get_int_opt(\"{}\")", name),
                )
            }
        }
        FieldType::Int8 => {
            if field.is_required {
                (
                    "i64".to_string(),
                    format!("self.data.get_int8_opt(\"{}\").unwrap_or(0)", name),
                )
            } else {
                (
                    "Option<i64>".to_string(),
                    format!("self.data.get_int8_opt(\"{}\")", name),
                )
            }
        }
        FieldType::BigInt => {
            if field.is_required {
                ("BigInt".to_string(), format!("self.data.get_bigint(\"{}\")", name))
            } else {
                ("Option<BigInt>".to_string(), format!("self.data.get_bigint_opt(\"{}\")", name))
            }
        }
        FieldType::BigDecimal => {
            if field.is_required {
                ("BigDecimal".to_string(), format!("self.data.get_big_decimal(\"{}\")", name))
            } else {
                ("Option<BigDecimal>".to_string(), format!("self.data.get_big_decimal_opt(\"{}\")", name))
            }
        }
        FieldType::Bytes => {
            if field.is_required {
                ("Bytes".to_string(), format!("self.data.get_bytes(\"{}\")", name))
            } else {
                ("Option<Bytes>".to_string(), format!("self.data.get_bytes_opt(\"{}\")", name))
            }
        }
        FieldType::Boolean => {
            if field.is_required {
                (
                    "bool".to_string(),
                    format!("self.data.get_bool_opt(\"{}\").unwrap_or(false)", name),
                )
            } else {
                (
                    "Option<bool>".to_string(),
                    format!("self.data.get_bool_opt(\"{}\")", name),
                )
            }
        }
        FieldType::Array(inner) => {
            match inner.as_ref() {
                FieldType::String | FieldType::Id => {
                    ("Vec<String>".to_string(), format!("self.data.get_string_array(\"{}\")", name))
                }
                FieldType::Bytes => {
                    ("Vec<Bytes>".to_string(), format!("self.data.get_bytes_array(\"{}\")", name))
                }
                FieldType::BigInt => {
                    ("Vec<BigInt>".to_string(), format!("self.data.get_bigint_array(\"{}\")", name))
                }
                FieldType::BigDecimal => {
                    ("Vec<BigDecimal>".to_string(), format!("self.data.get_big_decimal_array(\"{}\")", name))
                }
                FieldType::Int => {
                    ("Vec<i32>".to_string(), format!("self.data.get_int_array(\"{}\")", name))
                }
                FieldType::Int8 => {
                    ("Vec<i64>".to_string(), format!("self.data.get_int_array(\"{}\").into_iter().map(|i| i as i64).collect()", name))
                }
                FieldType::Boolean => {
                    ("Vec<bool>".to_string(), format!("self.data.get_bool_array(\"{}\")", name))
                }
                FieldType::Reference(_) => {
                    // References stored as ID strings
                    ("Vec<String>".to_string(), format!("self.data.get_string_array(\"{}\")", name))
                }
                FieldType::Array(_) => {
                    // Nested arrays - rare but possible
                    ("Vec<Value>".to_string(), format!("self.data.get_array(\"{}\").cloned().unwrap_or_default()", name))
                }
            }
        }
        FieldType::Reference(_) => {
            // References are stored as ID strings
            if field.is_required {
                ("String".to_string(), format!("self.data.get_string(\"{}\").to_string()", name))
            } else {
                ("Option<String>".to_string(), format!("self.data.get_string_opt(\"{}\").map(|s| s.to_string())", name))
            }
        }
    };

    format!(
        "    pub fn {}(&self) -> {} {{\n        {}\n    }}\n\n",
        method_name, return_type, getter_body
    )
}

fn generate_setter(field: &Field) -> String {
    let name = &field.name;
    let snake_name = to_snake_case(name);
    let method_name = format!("set_{}", snake_name);

    // Generate the basic setter first
    let (param_type, value_expr) = match &field.field_type {
        FieldType::Id | FieldType::String => {
            ("impl Into<String>".to_string(), "Value::String(val.into())")
        }
        FieldType::Int => ("i32".to_string(), "Value::Int(val)"),
        FieldType::Int8 => ("i64".to_string(), "Value::Int8(val)"),
        FieldType::BigInt => ("impl Into<BigInt>".to_string(), "Value::BigInt(val.into())"),
        FieldType::BigDecimal => ("impl Into<BigDecimal>".to_string(), "Value::BigDecimal(val.into())"),
        FieldType::Bytes => ("impl Into<Bytes>".to_string(), "Value::Bytes(val.into())"),
        FieldType::Boolean => ("bool".to_string(), "Value::Bool(val)"),
        FieldType::Array(inner) => {
            let (param_type, map_expr) = match inner.as_ref() {
                FieldType::String | FieldType::Id => (
                    "impl IntoIterator<Item = impl Into<String>>",
                    "val.into_iter().map(|v| Value::String(v.into())).collect()",
                ),
                FieldType::Bytes => (
                    "impl IntoIterator<Item = impl Into<Bytes>>",
                    "val.into_iter().map(|v| Value::Bytes(v.into())).collect()",
                ),
                FieldType::BigInt => (
                    "impl IntoIterator<Item = impl Into<BigInt>>",
                    "val.into_iter().map(|v| Value::BigInt(v.into())).collect()",
                ),
                FieldType::BigDecimal => (
                    "impl IntoIterator<Item = impl Into<BigDecimal>>",
                    "val.into_iter().map(|v| Value::BigDecimal(v.into())).collect()",
                ),
                FieldType::Int => (
                    "impl IntoIterator<Item = i32>",
                    "val.into_iter().map(Value::Int).collect()",
                ),
                FieldType::Int8 => (
                    "impl IntoIterator<Item = i64>",
                    "val.into_iter().map(Value::Int8).collect()",
                ),
                FieldType::Boolean => (
                    "impl IntoIterator<Item = bool>",
                    "val.into_iter().map(Value::Bool).collect()",
                ),
                FieldType::Reference(_) => (
                    "impl IntoIterator<Item = impl Into<String>>",
                    "val.into_iter().map(|v| Value::String(v.into())).collect()",
                ),
                FieldType::Array(_) => {
                    // Nested arrays are complex, skip for now
                    return String::new();
                }
            };
            return format!(
                "    pub fn {}(&mut self, val: {}) {{\n        self.data.set(\"{}\", Value::Array({}));\n    }}\n\n",
                method_name, param_type, name, map_expr
            );
        }
        FieldType::Reference(_) => {
            ("impl Into<String>".to_string(), "Value::String(val.into())")
        }
    };

    let mut result = format!(
        "    pub fn {}(&mut self, val: {}) {{\n        self.data.set(\"{}\", {});\n    }}\n\n",
        method_name, param_type, name, value_expr
    );

    // For optional fields, also generate an unset method
    if !field.is_required {
        result.push_str(&format!(
            "    pub fn unset_{}(&mut self) {{\n        self.data.set(\"{}\", Value::Null);\n    }}\n\n",
            snake_name, name
        ));
    }

    result
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4);

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}
