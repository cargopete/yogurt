//! GraphQL schema parsing and Rust code generation.

use crate::error::{CodegenError, Result};

/// A parsed GraphQL schema.
#[derive(Debug)]
pub struct SchemaParser {
    pub entities: Vec<Entity>,
}

/// A GraphQL entity type.
#[derive(Debug)]
pub struct Entity {
    pub name: String,
    pub fields: Vec<Field>,
    pub is_immutable: bool,
}

/// A field in a GraphQL entity.
#[derive(Debug)]
pub struct Field {
    pub name: String,
    pub field_type: FieldType,
    pub is_required: bool,
    pub is_derived: bool,
    pub derived_from: Option<String>,
}

/// GraphQL field types.
#[derive(Debug, Clone)]
pub enum FieldType {
    Id,
    String,
    Int,
    Int8,
    BigInt,
    BigDecimal,
    Bytes,
    Boolean,
    Array(Box<FieldType>),
    Reference(String),
}

impl SchemaParser {
    /// Parse a GraphQL schema from content.
    pub fn parse(content: &str) -> Result<Self> {
        use graphql_parser::schema::{parse_schema, Definition, TypeDefinition};

        let doc = parse_schema::<String>(content)
            .map_err(|e| CodegenError::GraphQL(e.to_string()))?;

        let mut entities = Vec::new();

        for def in doc.definitions {
            if let Definition::TypeDefinition(TypeDefinition::Object(obj)) = def {
                // Check for @entity directive
                let is_entity = obj.directives.iter().any(|d| d.name == "entity");
                if !is_entity {
                    continue;
                }

                // Check for @entity(immutable: true)
                let is_immutable = obj.directives.iter().any(|d| {
                    d.name == "entity"
                        && d.arguments.iter().any(|(k, v)| {
                            k == "immutable" && matches!(v, graphql_parser::schema::Value::Boolean(true))
                        })
                });

                let mut fields = Vec::new();

                for field in &obj.fields {
                    // Check for @derivedFrom directive
                    let derived_from = field
                        .directives
                        .iter()
                        .find(|d| d.name == "derivedFrom")
                        .and_then(|d| {
                            d.arguments.iter().find(|(k, _)| k == "field").map(|(_, v)| {
                                if let graphql_parser::schema::Value::String(s) = v {
                                    s.clone()
                                } else {
                                    String::new()
                                }
                            })
                        });

                    let is_derived = derived_from.is_some();

                    let (field_type, is_required) = parse_field_type(&field.field_type)?;

                    fields.push(Field {
                        name: field.name.clone(),
                        field_type,
                        is_required,
                        is_derived,
                        derived_from,
                    });
                }

                entities.push(Entity {
                    name: obj.name.clone(),
                    fields,
                    is_immutable,
                });
            }
        }

        Ok(SchemaParser { entities })
    }

    /// Generate Rust code for all entities.
    pub fn generate_rust(&self) -> String {
        let mut code = String::from(
            "//! Auto-generated by yogurt codegen â€” do not edit\n\n\
             use yogurt_runtime::prelude::*;\n\
             use yogurt_runtime::store;\n\
             use yogurt_runtime::types::{EntityData, Value};\n\n",
        );

        for entity in &self.entities {
            code.push_str(&generate_entity_struct(entity));
            code.push('\n');
        }

        code
    }
}

fn parse_field_type(
    ty: &graphql_parser::schema::Type<String>,
) -> Result<(FieldType, bool)> {
    use graphql_parser::schema::Type;

    match ty {
        Type::NonNullType(inner) => {
            let (ft, _) = parse_field_type(inner)?;
            Ok((ft, true))
        }
        Type::ListType(inner) => {
            let (ft, _) = parse_field_type(inner)?;
            Ok((FieldType::Array(Box::new(ft)), false))
        }
        Type::NamedType(name) => {
            let ft = match name.as_str() {
                "ID" => FieldType::Id,
                "String" => FieldType::String,
                "Int" => FieldType::Int,
                "Int8" => FieldType::Int8,
                "BigInt" => FieldType::BigInt,
                "BigDecimal" => FieldType::BigDecimal,
                "Bytes" => FieldType::Bytes,
                "Boolean" => FieldType::Boolean,
                other => FieldType::Reference(other.to_string()),
            };
            Ok((ft, false))
        }
    }
}

fn generate_entity_struct(entity: &Entity) -> String {
    let name = &entity.name;

    let mut code = format!(
        "pub struct {} {{\n    data: EntityData,\n}}\n\n",
        name
    );

    // Constructor
    code.push_str(&format!(
        "impl {name} {{\n\
            pub fn new(id: impl Into<String>) -> Self {{\n\
                let mut data = EntityData::new();\n\
                data.set(\"id\", Value::String(id.into()));\n\
                Self {{ data }}\n\
            }}\n\n",
        name = name
    ));

    // Getters
    for field in &entity.fields {
        if field.is_derived {
            continue; // Skip derived fields
        }

        let getter = generate_getter(field);
        code.push_str(&getter);
    }

    // Setters
    for field in &entity.fields {
        if field.is_derived || field.name == "id" {
            continue; // Skip derived fields and id
        }

        let setter = generate_setter(field);
        code.push_str(&setter);
    }

    code.push_str("}\n\n");

    // Entity trait implementation
    code.push_str(&format!(
        "impl Entity for {name} {{\n\
            const ENTITY_TYPE: &'static str = \"{name}\";\n\n\
            fn id(&self) -> &str {{\n\
                self.data.get_string(\"id\")\n\
            }}\n\n\
            fn save(&self) {{\n\
                store::set(Self::ENTITY_TYPE, self.id(), &self.data);\n\
            }}\n\n\
            fn load(id: &str) -> Option<Self> {{\n\
                store::get(Self::ENTITY_TYPE, id).map(|data| Self {{ data }})\n\
            }}\n\n\
            fn remove(id: &str) {{\n\
                store::remove(Self::ENTITY_TYPE, id);\n\
            }}\n\
        }}\n",
        name = name
    ));

    code
}

fn generate_getter(field: &Field) -> String {
    let name = &field.name;
    let method_name = to_snake_case(name);

    let (return_type, getter_body) = match &field.field_type {
        FieldType::Id | FieldType::String => {
            if field.is_required {
                ("&str".to_string(), format!("self.data.get_string(\"{}\")", name))
            } else {
                ("Option<&str>".to_string(), format!("self.data.get_string_opt(\"{}\")", name))
            }
        }
        FieldType::Int => {
            let body = format!("self.data.get(\"{}\").and_then(|v| match v {{ Value::Int(i) => Some(*i), _ => None }}).unwrap_or(0)", name);
            ("i32".to_string(), body)
        }
        FieldType::Int8 => {
            let body = format!("self.data.get(\"{}\").and_then(|v| match v {{ Value::Int8(i) => Some(*i), _ => None }}).unwrap_or(0)", name);
            ("i64".to_string(), body)
        }
        FieldType::BigInt => ("BigInt".to_string(), format!("self.data.get_bigint(\"{}\")", name)),
        FieldType::BigDecimal => ("BigDecimal".to_string(), format!("self.data.get_big_decimal(\"{}\")", name)),
        FieldType::Bytes => ("Bytes".to_string(), format!("self.data.get_bytes(\"{}\")", name)),
        FieldType::Boolean => {
            let body = format!("self.data.get(\"{}\").and_then(|v| match v {{ Value::Bool(b) => Some(*b), _ => None }}).unwrap_or(false)", name);
            ("bool".to_string(), body)
        }
        FieldType::Array(_) => {
            // TODO: Implement array getters
            ("Vec<Value>".to_string(), "Vec::new()".to_string())
        }
        FieldType::Reference(ref_type) => {
            // References are stored as ID strings
            ("String".to_string(), format!("self.data.get_string(\"{}\").to_string()", name))
        }
    };

    format!(
        "    pub fn {}(&self) -> {} {{\n        {}\n    }}\n\n",
        method_name, return_type, getter_body
    )
}

fn generate_setter(field: &Field) -> String {
    let name = &field.name;
    let method_name = format!("set_{}", to_snake_case(name));

    let (param_type, value_expr) = match &field.field_type {
        FieldType::Id | FieldType::String => {
            ("impl Into<String>".to_string(), "Value::String(val.into())")
        }
        FieldType::Int => ("i32".to_string(), "Value::Int(val)"),
        FieldType::Int8 => ("i64".to_string(), "Value::Int8(val)"),
        FieldType::BigInt => ("impl Into<BigInt>".to_string(), "Value::BigInt(val.into())"),
        FieldType::BigDecimal => ("impl Into<BigDecimal>".to_string(), "Value::BigDecimal(val.into())"),
        FieldType::Bytes => ("impl Into<Bytes>".to_string(), "Value::Bytes(val.into())"),
        FieldType::Boolean => ("bool".to_string(), "Value::Bool(val)"),
        FieldType::Array(_) => {
            // TODO: Implement array setters
            return String::new();
        }
        FieldType::Reference(_) => {
            ("impl Into<String>".to_string(), "Value::String(val.into())")
        }
    };

    format!(
        "    pub fn {}(&mut self, val: {}) {{\n        self.data.set(\"{}\", {});\n    }}\n\n",
        method_name, param_type, name, value_expr
    )
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4);

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}
