//! Ethereum ABI parsing and Rust code generation.

use alloy_json_abi::{Event, Function, JsonAbi};
use crate::error::{CodegenError, Result};

/// A parsed Ethereum ABI.
#[derive(Debug)]
pub struct AbiParser {
    pub events: Vec<ParsedEvent>,
    pub functions: Vec<ParsedFunction>,
}

/// A parsed event from an ABI.
#[derive(Debug)]
pub struct ParsedEvent {
    pub name: String,
    pub inputs: Vec<EventInput>,
    pub signature: String,
}

/// An event input parameter.
#[derive(Debug)]
pub struct EventInput {
    pub name: String,
    pub solidity_type: String,
    pub indexed: bool,
}

/// A parsed function from an ABI.
#[derive(Debug)]
pub struct ParsedFunction {
    pub name: String,
    pub inputs: Vec<FunctionParam>,
    pub outputs: Vec<FunctionParam>,
    pub signature: String,
    pub state_mutability: String,
}

/// A function input/output parameter.
#[derive(Debug)]
pub struct FunctionParam {
    pub name: String,
    pub solidity_type: String,
}

impl AbiParser {
    /// Parse an ABI from JSON content.
    pub fn parse(content: &str) -> Result<Self> {
        let abi: JsonAbi = serde_json::from_str(content)?;

        let events: Vec<ParsedEvent> = abi
            .events()
            .map(|e| ParsedEvent {
                name: e.name.clone(),
                inputs: e
                    .inputs
                    .iter()
                    .map(|i| EventInput {
                        name: i.name.clone(),
                        solidity_type: i.ty.to_string(),
                        indexed: i.indexed,
                    })
                    .collect(),
                signature: e.signature(),
            })
            .collect();

        let functions: Vec<ParsedFunction> = abi
            .functions()
            .filter(|f| !f.name.is_empty())
            .map(|f| ParsedFunction {
                name: f.name.clone(),
                inputs: f
                    .inputs
                    .iter()
                    .map(|i| FunctionParam {
                        name: if i.name.is_empty() {
                            format!("param{}", f.inputs.iter().position(|x| x == i).unwrap_or(0))
                        } else {
                            i.name.clone()
                        },
                        solidity_type: i.ty.to_string(),
                    })
                    .collect(),
                outputs: f
                    .outputs
                    .iter()
                    .enumerate()
                    .map(|(i, o)| FunctionParam {
                        name: if o.name.is_empty() {
                            format!("output{}", i)
                        } else {
                            o.name.clone()
                        },
                        solidity_type: o.ty.to_string(),
                    })
                    .collect(),
                signature: f.signature(),
                state_mutability: format!("{:?}", f.state_mutability),
            })
            .collect();

        Ok(AbiParser { events, functions })
    }

    /// Generate Rust code for this ABI.
    pub fn generate_rust(&self, contract_name: &str) -> String {
        let mut code = String::from(
            "//! Auto-generated by yogurt codegen â€” do not edit\n\n\
             use yogurt_runtime::prelude::*;\n\
             use yogurt_runtime::ethereum::{Event, SmartContractCall, Token};\n\n",
        );

        // Generate event structs
        for event in &self.events {
            code.push_str(&generate_event_struct(event));
            code.push('\n');
        }

        // Generate contract binding
        code.push_str(&generate_contract_binding(contract_name, &self.functions));

        code
    }
}

fn generate_event_struct(event: &ParsedEvent) -> String {
    let event_name = &event.name;
    let params_struct_name = format!("{}Params", event_name);
    let event_struct_name = format!("{}Event", event_name);

    let mut code = format!(
        "/// {}({})\n",
        event_name,
        event.inputs.iter().map(|i| format!("{} {}", i.solidity_type, i.name)).collect::<Vec<_>>().join(", ")
    );

    // Params struct
    code.push_str(&format!("pub struct {} {{\n", params_struct_name));
    for input in &event.inputs {
        let rust_type = solidity_to_rust_type(&input.solidity_type);
        code.push_str(&format!("    pub {}: {},\n", to_snake_case(&input.name), rust_type));
    }
    code.push_str("}\n\n");

    // Event type alias using the generic Event<P>
    code.push_str(&format!(
        "pub type {} = Event<{}>;\n\n",
        event_struct_name, params_struct_name
    ));

    // FromAscPtr implementation for the event
    code.push_str(&format!(
        "impl {name} {{\n\
            /// Deserialize from an AscPtr passed by graph-node.\n\
            pub(crate) fn from_asc_ptr(_ptr: u32) -> Self {{\n\
                // TODO: Implement full deserialization from AS memory layout\n\
                unimplemented!(\"Event deserialization not yet implemented\")\n\
            }}\n\
        }}\n",
        name = event_struct_name
    ));

    code
}

fn generate_contract_binding(name: &str, functions: &[ParsedFunction]) -> String {
    let struct_name = to_pascal_case(name);

    let mut code = format!(
        "/// Binding for the {name} contract.\n\
        pub struct {struct_name} {{\n\
            address: Address,\n\
        }}\n\n\
        impl {struct_name} {{\n\
            /// Bind to a deployed contract at the given address.\n\
            pub fn bind(address: Address) -> Self {{\n\
                Self {{ address }}\n\
            }}\n\n",
        name = name,
        struct_name = struct_name
    );

    // Generate method for each view/pure function
    for func in functions {
        if func.state_mutability != "View" && func.state_mutability != "Pure" {
            continue;
        }

        let method_name = to_snake_case(&func.name);
        let return_type = if func.outputs.is_empty() {
            "()".to_string()
        } else if func.outputs.len() == 1 {
            solidity_to_rust_type(&func.outputs[0].solidity_type)
        } else {
            format!(
                "({})",
                func.outputs
                    .iter()
                    .map(|o| solidity_to_rust_type(&o.solidity_type))
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        };

        // Build parameter list
        let params: Vec<String> = func
            .inputs
            .iter()
            .map(|i| format!("{}: {}", to_snake_case(&i.name), solidity_to_rust_type(&i.solidity_type)))
            .collect();

        let params_str = if params.is_empty() {
            "&self".to_string()
        } else {
            format!("&self, {}", params.join(", "))
        };

        let call_args = func.inputs.iter().map(|i| to_snake_case(&i.name)).collect::<Vec<_>>().join(", ");
        code.push_str(&format!(
            "    /// Call `{func_name}`\n\
            pub fn {method_name}({params_str}) -> Result<{return_type}, String> {{\n\
                // TODO: Implement contract call\n\
                Err(\"Contract calls not yet implemented\".into())\n\
            }}\n\n\
            /// Try to call `{func_name}`, returning None on revert.\n\
            pub fn try_{method_name}({params_str}) -> Option<{return_type}> {{\n\
                self.{method_name}({call_args}).ok()\n\
            }}\n\n",
            func_name = func.name,
            method_name = method_name,
            params_str = params_str,
            return_type = return_type,
            call_args = call_args
        ));
    }

    code.push_str("}\n");
    code
}

fn solidity_to_rust_type(sol_type: &str) -> String {
    match sol_type {
        "address" => "Address".to_string(),
        "bool" => "bool".to_string(),
        "string" => "String".to_string(),
        "bytes" => "Bytes".to_string(),
        t if t.starts_with("uint") => {
            let bits: u32 = t[4..].parse().unwrap_or(256);
            if bits <= 64 {
                "u64".to_string()
            } else {
                "BigInt".to_string()
            }
        }
        t if t.starts_with("int") => {
            let bits: u32 = t[3..].parse().unwrap_or(256);
            if bits <= 64 {
                "i64".to_string()
            } else {
                "BigInt".to_string()
            }
        }
        t if t.starts_with("bytes") => "Bytes".to_string(),
        t if t.ends_with("[]") => {
            let inner = &t[..t.len() - 2];
            format!("Vec<{}>", solidity_to_rust_type(inner))
        }
        _ => "Bytes".to_string(), // Fallback for unknown types
    }
}

fn to_snake_case(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }

    let mut result = String::with_capacity(s.len() + 4);

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == ' ' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}
