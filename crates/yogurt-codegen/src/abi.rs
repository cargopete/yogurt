//! Ethereum ABI parsing and Rust code generation.

use alloy_json_abi::JsonAbi;
use crate::error::Result;

/// A parsed Ethereum ABI.
#[derive(Debug)]
pub struct AbiParser {
    pub events: Vec<ParsedEvent>,
    pub functions: Vec<ParsedFunction>,
}

/// A parsed event from an ABI.
#[derive(Debug)]
pub struct ParsedEvent {
    pub name: String,
    pub inputs: Vec<EventInput>,
    pub signature: String,
}

/// An event input parameter.
#[derive(Debug, Clone)]
pub struct EventInput {
    pub name: String,
    pub solidity_type: String,
    pub indexed: bool,
    /// Tuple components (empty for non-tuple types).
    /// Stored as FunctionParam for consistency with type resolution.
    pub components: Vec<FunctionParam>,
}

/// A parsed function from an ABI.
#[derive(Debug)]
pub struct ParsedFunction {
    pub name: String,
    pub inputs: Vec<FunctionParam>,
    pub outputs: Vec<FunctionParam>,
    pub signature: String,
    pub state_mutability: String,
}

/// A function input/output parameter.
#[derive(Debug, Clone)]
pub struct FunctionParam {
    pub name: String,
    pub solidity_type: String,
    /// Tuple components (empty for non-tuple types).
    pub components: Vec<FunctionParam>,
}

impl AbiParser {
    /// Parse an ABI from JSON content.
    pub fn parse(content: &str) -> Result<Self> {
        let abi: JsonAbi = serde_json::from_str(content)?;

        let events: Vec<ParsedEvent> = abi
            .events()
            .map(|e| ParsedEvent {
                name: e.name.clone(),
                inputs: e
                    .inputs
                    .iter()
                    .map(|i| parse_event_input(i))
                    .collect(),
                signature: e.signature(),
            })
            .collect();

        let functions: Vec<ParsedFunction> = abi
            .functions()
            .filter(|f| !f.name.is_empty())
            .map(|f| ParsedFunction {
                name: f.name.clone(),
                inputs: f
                    .inputs
                    .iter()
                    .enumerate()
                    .map(|(idx, i)| parse_function_param(i, idx, "param"))
                    .collect(),
                outputs: f
                    .outputs
                    .iter()
                    .enumerate()
                    .map(|(idx, o)| parse_function_param(o, idx, "output"))
                    .collect(),
                signature: f.signature(),
                state_mutability: format!("{:?}", f.state_mutability),
            })
            .collect();

        Ok(AbiParser { events, functions })
    }
}

/// Parse an event input parameter, recursively handling tuple components.
fn parse_event_input(param: &alloy_json_abi::EventParam) -> EventInput {
    EventInput {
        name: param.name.clone(),
        solidity_type: param.ty.to_string(),
        indexed: param.indexed,
        components: parse_param_components(&param.components),
    }
}

/// Parse a function parameter, recursively handling tuple components.
fn parse_function_param(
    param: &alloy_json_abi::Param,
    index: usize,
    prefix: &str,
) -> FunctionParam {
    FunctionParam {
        name: if param.name.is_empty() {
            format!("{}{}", prefix, index)
        } else {
            param.name.clone()
        },
        solidity_type: param.ty.to_string(),
        components: parse_param_components(&param.components),
    }
}

/// Recursively parse tuple components from alloy Param.
fn parse_param_components(components: &[alloy_json_abi::Param]) -> Vec<FunctionParam> {
    components
        .iter()
        .enumerate()
        .map(|(idx, c)| FunctionParam {
            name: if c.name.is_empty() {
                format!("field{}", idx)
            } else {
                c.name.clone()
            },
            solidity_type: c.ty.to_string(),
            components: parse_param_components(&c.components),
        })
        .collect()
}

impl AbiParser {
    /// Generate Rust code for this ABI.
    pub fn generate_rust(&self, contract_name: &str) -> String {
        let mut code = String::from(
            "//! Auto-generated by yogurt codegen â€” do not edit\n\n\
             use yogurt_runtime::prelude::*;\n\
             use yogurt_runtime::ethereum::{Event, SmartContractCall, Token};\n\n",
        );

        // Generate event structs
        for event in &self.events {
            code.push_str(&generate_event_struct(event));
            code.push('\n');
        }

        // Generate contract binding
        code.push_str(&generate_contract_binding(contract_name, &self.functions));

        code
    }
}

fn generate_event_struct(event: &ParsedEvent) -> String {
    let event_name = &event.name;
    let params_struct_name = format!("{}Params", event_name);
    let event_struct_name = format!("{}Event", event_name);

    let mut code = format!(
        "/// {}({})\n",
        event_name,
        event.inputs.iter().map(|i| format!("{} {}", i.solidity_type, i.name)).collect::<Vec<_>>().join(", ")
    );

    // Params struct
    code.push_str(&format!("pub struct {} {{\n", params_struct_name));
    for input in &event.inputs {
        let rust_type = solidity_to_rust_type_with_components(&input.solidity_type, &input.components);
        code.push_str(&format!("    pub {}: {},\n", to_snake_case(&input.name), rust_type));
    }
    code.push_str("}\n\n");

    // Event type alias using the generic Event<P>
    code.push_str(&format!(
        "pub type {} = Event<{}>;\n\n",
        event_struct_name, params_struct_name
    ));

    // FromAscPtr implementation for the event
    code.push_str(&format!(
        "impl {name} {{\n\
            /// Deserialize from an AscPtr passed by graph-node.\n\
            pub(crate) fn from_asc_ptr(_ptr: u32) -> Self {{\n\
                // TODO: Implement full deserialization from AS memory layout\n\
                unimplemented!(\"Event deserialization not yet implemented\")\n\
            }}\n\
        }}\n",
        name = event_struct_name
    ));

    code
}

fn generate_contract_binding(name: &str, functions: &[ParsedFunction]) -> String {
    let struct_name = to_pascal_case(name);

    let mut code = format!(
        "/// Binding for the {name} contract.\n\
        pub struct {struct_name} {{\n\
            address: Address,\n\
        }}\n\n\
        impl {struct_name} {{\n\
            /// Bind to a deployed contract at the given address.\n\
            pub fn bind(address: Address) -> Self {{\n\
                Self {{ address }}\n\
            }}\n\n",
        name = name,
        struct_name = struct_name
    );

    // Generate method for each view/pure function
    for func in functions {
        if func.state_mutability != "View" && func.state_mutability != "Pure" {
            continue;
        }

        let method_name = to_snake_case(&func.name);
        let return_type = if func.outputs.is_empty() {
            "()".to_string()
        } else if func.outputs.len() == 1 {
            solidity_to_rust_type_with_components(&func.outputs[0].solidity_type, &func.outputs[0].components)
        } else {
            format!(
                "({})",
                func.outputs
                    .iter()
                    .map(|o| solidity_to_rust_type_with_components(&o.solidity_type, &o.components))
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        };

        // Build parameter list
        let params: Vec<String> = func
            .inputs
            .iter()
            .map(|i| format!("{}: {}", to_snake_case(&i.name), solidity_to_rust_type_with_components(&i.solidity_type, &i.components)))
            .collect();

        let params_str = if params.is_empty() {
            "&self".to_string()
        } else {
            format!("&self, {}", params.join(", "))
        };

        // Generate token conversion for each input
        let token_conversions: Vec<String> = func
            .inputs
            .iter()
            .map(|i| {
                let var_name = to_snake_case(&i.name);
                solidity_to_token_conversion_with_components(&var_name, &i.solidity_type, &i.components)
            })
            .collect();

        let tokens_array = if token_conversions.is_empty() {
            "vec![]".to_string()
        } else {
            format!("vec![{}]", token_conversions.join(", "))
        };

        // Generate return value extraction
        let return_extraction = generate_return_extraction(&func.outputs);

        let call_args = func.inputs.iter().map(|i| to_snake_case(&i.name)).collect::<Vec<_>>().join(", ");
        code.push_str(&format!(
            "    /// Call `{func_name}`\n\
            pub fn {method_name}({params_str}) -> Result<{return_type}, String> {{\n\
                use yogurt_runtime::ethereum::{{SmartContractCall, Token, call}};\n\
                \n\
                let call_data = SmartContractCall {{\n\
                    contract_name: \"{contract_name}\".into(),\n\
                    contract_address: self.address.clone(),\n\
                    function_name: \"{func_name}\".into(),\n\
                    function_signature: \"{signature}\".into(),\n\
                    function_params: {tokens_array},\n\
                }};\n\
                \n\
                let result = call(call_data).ok_or_else(|| \"Call reverted\".to_string())?;\n\
                {return_extraction}\n\
            }}\n\n\
            /// Try to call `{func_name}`, returning None on revert.\n\
            pub fn try_{method_name}({params_str}) -> Option<{return_type}> {{\n\
                self.{method_name}({call_args}).ok()\n\
            }}\n\n",
            func_name = func.name,
            method_name = method_name,
            params_str = params_str,
            return_type = return_type,
            contract_name = name,
            signature = func.signature,
            tokens_array = tokens_array,
            return_extraction = return_extraction,
            call_args = call_args
        ));
    }

    code.push_str("}\n");
    code
}

fn solidity_to_rust_type(sol_type: &str) -> String {
    solidity_to_rust_type_with_components(sol_type, &[])
}

/// Convert a Solidity type to a Rust type, with optional tuple components.
fn solidity_to_rust_type_with_components(sol_type: &str, components: &[FunctionParam]) -> String {
    match sol_type {
        "address" => "Address".to_string(),
        "bool" => "bool".to_string(),
        "string" => "String".to_string(),
        "bytes" => "Bytes".to_string(),
        t if t.starts_with("uint") && !t.contains('[') => {
            let bits: u32 = t[4..].parse().unwrap_or(256);
            if bits <= 64 {
                "u64".to_string()
            } else {
                "BigInt".to_string()
            }
        }
        t if t.starts_with("int") && !t.contains('[') => {
            let bits: u32 = t[3..].parse().unwrap_or(256);
            if bits <= 64 {
                "i64".to_string()
            } else {
                "BigInt".to_string()
            }
        }
        t if t.starts_with("bytes") && !t.contains('[') => "Bytes".to_string(),
        // Tuple type: "tuple" or "tuple[]" or "tuple[N]"
        "tuple" => {
            if components.is_empty() {
                // No components available, fall back to Vec<Token>
                "Vec<Token>".to_string()
            } else {
                // Generate Rust tuple type from components
                let inner_types: Vec<String> = components
                    .iter()
                    .map(|c| solidity_to_rust_type_with_components(&c.solidity_type, &c.components))
                    .collect();
                format!("({})", inner_types.join(", "))
            }
        }
        // Fixed-size array: "type[N]" (must come before dynamic array check)
        t if t.contains('[') && !t.ends_with("[]") => {
            if let Some(bracket_pos) = t.rfind('[') {
                let inner = &t[..bracket_pos];
                let size_str = &t[bracket_pos + 1..t.len() - 1];
                if let Ok(size) = size_str.parse::<usize>() {
                    let inner_type = if inner == "tuple" {
                        solidity_to_rust_type_with_components(inner, components)
                    } else {
                        solidity_to_rust_type(inner)
                    };
                    return format!("[{}; {}]", inner_type, size);
                }
            }
            // Fallback if parsing fails
            "Bytes".to_string()
        }
        // Dynamic array: "type[]"
        t if t.ends_with("[]") => {
            let inner = &t[..t.len() - 2];
            let inner_type = if inner == "tuple" {
                solidity_to_rust_type_with_components(inner, components)
            } else {
                solidity_to_rust_type(inner)
            };
            format!("Vec<{}>", inner_type)
        }
        _ => "Bytes".to_string(), // Fallback for unknown types
    }
}

fn to_snake_case(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }

    let mut result = String::with_capacity(s.len() + 4);

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == ' ' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate code to convert a Rust value to a Token, with tuple component support.
fn solidity_to_token_conversion_with_components(
    var_name: &str,
    sol_type: &str,
    components: &[FunctionParam],
) -> String {
    match sol_type {
        "address" => format!("Token::Address({}.clone())", var_name),
        "bool" => format!("Token::Bool({})", var_name),
        "string" => format!("Token::String({}.clone())", var_name),
        "bytes" => format!("Token::Bytes({}.clone())", var_name),
        t if t.starts_with("uint") && !t.contains('[') => format!("Token::Uint({}.clone())", var_name),
        t if t.starts_with("int") && !t.contains('[') => format!("Token::Int({}.clone())", var_name),
        t if t.starts_with("bytes") && !t.contains('[') && t.len() > 5 => {
            // Fixed bytes like bytes32
            format!("Token::FixedBytes({}.as_slice().to_vec())", var_name)
        }
        // Tuple type
        "tuple" => {
            if components.is_empty() {
                // No component info, treat as raw token vec
                format!("Token::Tuple({}.clone())", var_name)
            } else {
                // Convert each tuple field
                let conversions: Vec<String> = components
                    .iter()
                    .enumerate()
                    .map(|(i, c)| {
                        let field_access = format!("{}.{}", var_name, i);
                        solidity_to_token_conversion_with_components(&field_access, &c.solidity_type, &c.components)
                    })
                    .collect();
                format!("Token::Tuple(vec![{}])", conversions.join(", "))
            }
        }
        // Fixed-size array: "type[N]" (must come before dynamic array)
        t if t.contains('[') && !t.ends_with("[]") => {
            if let Some(bracket_pos) = t.rfind('[') {
                let inner = &t[..bracket_pos];
                format!(
                    "Token::FixedArray({}.iter().map(|v| {}).collect())",
                    var_name,
                    solidity_to_token_conversion_with_components("(*v)", inner, components)
                )
            } else {
                format!("Token::FixedArray({}.to_vec())", var_name)
            }
        }
        // Dynamic array: "type[]"
        t if t.ends_with("[]") => {
            let inner = &t[..t.len() - 2];
            format!(
                "Token::Array({}.iter().map(|v| {}).collect())",
                var_name,
                solidity_to_token_conversion_with_components("v", inner, components)
            )
        }
        _ => format!("Token::Bytes({}.clone())", var_name), // Fallback
    }
}

/// Generate code to extract return values from Token array.
fn generate_return_extraction(outputs: &[FunctionParam]) -> String {
    if outputs.is_empty() {
        return "Ok(())".to_string();
    }

    if outputs.len() == 1 {
        let extraction = token_to_rust_extraction_with_components(
            "result.get(0)",
            &outputs[0].solidity_type,
            &outputs[0].components,
        );
        return format!(
            "let value = {};\n\
            Ok(value)",
            extraction
        );
    }

    // Multiple outputs - return a tuple
    let extractions: Vec<String> = outputs
        .iter()
        .enumerate()
        .map(|(i, o)| {
            token_to_rust_extraction_with_components(
                &format!("result.get({})", i),
                &o.solidity_type,
                &o.components,
            )
        })
        .collect();

    format!(
        "Ok(({}),)",
        extractions.join(", ")
    )
}

/// Generate code to extract a Rust value from a Token.
fn token_to_rust_extraction_with_components(
    expr: &str,
    sol_type: &str,
    components: &[FunctionParam],
) -> String {
    match sol_type {
        "address" => format!(
            "match {} {{ Some(Token::Address(a)) => a.clone(), _ => Address::zero() }}",
            expr
        ),
        "bool" => format!(
            "match {} {{ Some(Token::Bool(b)) => *b, _ => false }}",
            expr
        ),
        "string" => format!(
            "match {} {{ Some(Token::String(s)) => s.clone(), _ => String::new() }}",
            expr
        ),
        "bytes" => format!(
            "match {} {{ Some(Token::Bytes(b)) => b.clone(), _ => Bytes::new() }}",
            expr
        ),
        t if t.starts_with("uint") && !t.contains('[') => {
            let bits: u32 = t[4..].parse().unwrap_or(256);
            if bits <= 64 {
                format!(
                    "match {} {{ Some(Token::Uint(n)) => {{ let s = n.to_string(); s.parse::<u64>().unwrap_or(0) }}, _ => 0 }}",
                    expr
                )
            } else {
                format!(
                    "match {} {{ Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() }}",
                    expr
                )
            }
        }
        t if t.starts_with("int") && !t.contains('[') => {
            let bits: u32 = t[3..].parse().unwrap_or(256);
            if bits <= 64 {
                format!(
                    "match {} {{ Some(Token::Int(n)) => {{ let s = n.to_string(); s.parse::<i64>().unwrap_or(0) }}, _ => 0 }}",
                    expr
                )
            } else {
                format!(
                    "match {} {{ Some(Token::Int(n)) => n.clone(), _ => BigInt::zero() }}",
                    expr
                )
            }
        }
        t if t.starts_with("bytes") && !t.contains('[') && t.len() > 5 => {
            format!(
                "match {} {{ Some(Token::FixedBytes(b)) => Bytes::from(b.as_slice()), _ => Bytes::new() }}",
                expr
            )
        }
        // Tuple type
        "tuple" => {
            if components.is_empty() {
                // No component info, return raw token vec
                format!(
                    "match {} {{ Some(Token::Tuple(t)) => t.clone(), _ => Vec::new() }}",
                    expr
                )
            } else {
                // Extract each tuple field
                let field_extractions: Vec<String> = components
                    .iter()
                    .enumerate()
                    .map(|(i, c)| {
                        token_to_rust_extraction_with_components(
                            &format!("tuple_tokens.get({})", i),
                            &c.solidity_type,
                            &c.components,
                        )
                    })
                    .collect();
                format!(
                    "match {} {{ Some(Token::Tuple(tuple_tokens)) => ({},), _ => Default::default() }}",
                    expr,
                    field_extractions.join(", ")
                )
            }
        }
        // Fixed-size array: "type[N]"
        t if t.contains('[') && !t.ends_with("[]") => {
            if let Some(bracket_pos) = t.rfind('[') {
                let inner = &t[..bracket_pos];
                let size_str = &t[bracket_pos + 1..t.len() - 1];
                if let Ok(size) = size_str.parse::<usize>() {
                    let inner_extraction = token_to_rust_extraction_with_components(
                        "Some(token)",
                        inner,
                        components,
                    );
                    return format!(
                        "match {} {{ Some(Token::FixedArray(arr)) => {{ \
                            let mut result: [_; {}] = Default::default(); \
                            for (i, token) in arr.iter().enumerate().take({}) {{ \
                                result[i] = {}; \
                            }} \
                            result \
                        }}, _ => Default::default() }}",
                        expr, size, size, inner_extraction
                    );
                }
            }
            // Fallback
            format!(
                "match {} {{ Some(Token::FixedArray(arr)) => arr.clone(), _ => Vec::new() }}",
                expr
            )
        }
        // Dynamic array: "type[]"
        t if t.ends_with("[]") => {
            let inner = &t[..t.len() - 2];
            let inner_extraction = token_to_rust_extraction_with_components(
                "Some(token)",
                inner,
                components,
            );
            format!(
                "match {} {{ Some(Token::Array(arr)) => arr.iter().map(|token| {}).collect(), _ => Vec::new() }}",
                expr, inner_extraction
            )
        }
        _ => format!(
            "match {} {{ Some(Token::Bytes(b)) => b.clone(), _ => Bytes::new() }}",
            expr
        ),
    }
}
