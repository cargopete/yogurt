//! Ethereum ABI parsing and Rust code generation.

use alloy_json_abi::{Event, Function, JsonAbi};
use crate::error::{CodegenError, Result};

/// A parsed Ethereum ABI.
#[derive(Debug)]
pub struct AbiParser {
    pub events: Vec<ParsedEvent>,
    pub functions: Vec<ParsedFunction>,
}

/// A parsed event from an ABI.
#[derive(Debug)]
pub struct ParsedEvent {
    pub name: String,
    pub inputs: Vec<EventInput>,
    pub signature: String,
}

/// An event input parameter.
#[derive(Debug)]
pub struct EventInput {
    pub name: String,
    pub solidity_type: String,
    pub indexed: bool,
}

/// A parsed function from an ABI.
#[derive(Debug)]
pub struct ParsedFunction {
    pub name: String,
    pub inputs: Vec<FunctionParam>,
    pub outputs: Vec<FunctionParam>,
    pub signature: String,
    pub state_mutability: String,
}

/// A function input/output parameter.
#[derive(Debug)]
pub struct FunctionParam {
    pub name: String,
    pub solidity_type: String,
}

impl AbiParser {
    /// Parse an ABI from JSON content.
    pub fn parse(content: &str) -> Result<Self> {
        let abi: JsonAbi = serde_json::from_str(content)?;

        let events: Vec<ParsedEvent> = abi
            .events()
            .map(|e| ParsedEvent {
                name: e.name.clone(),
                inputs: e
                    .inputs
                    .iter()
                    .map(|i| EventInput {
                        name: i.name.clone(),
                        solidity_type: i.ty.to_string(),
                        indexed: i.indexed,
                    })
                    .collect(),
                signature: e.signature(),
            })
            .collect();

        let functions: Vec<ParsedFunction> = abi
            .functions()
            .filter(|f| !f.name.is_empty())
            .map(|f| ParsedFunction {
                name: f.name.clone(),
                inputs: f
                    .inputs
                    .iter()
                    .map(|i| FunctionParam {
                        name: if i.name.is_empty() {
                            format!("param{}", f.inputs.iter().position(|x| x == i).unwrap_or(0))
                        } else {
                            i.name.clone()
                        },
                        solidity_type: i.ty.to_string(),
                    })
                    .collect(),
                outputs: f
                    .outputs
                    .iter()
                    .enumerate()
                    .map(|(i, o)| FunctionParam {
                        name: if o.name.is_empty() {
                            format!("output{}", i)
                        } else {
                            o.name.clone()
                        },
                        solidity_type: o.ty.to_string(),
                    })
                    .collect(),
                signature: f.signature(),
                state_mutability: format!("{:?}", f.state_mutability),
            })
            .collect();

        Ok(AbiParser { events, functions })
    }

    /// Generate Rust code for this ABI.
    pub fn generate_rust(&self, contract_name: &str) -> String {
        let mut code = String::from(
            "//! Auto-generated by yogurt codegen â€” do not edit\n\n\
             use yogurt_runtime::prelude::*;\n\
             use yogurt_runtime::ethereum::{Event, SmartContractCall, Token};\n\n",
        );

        // Generate event structs
        for event in &self.events {
            code.push_str(&generate_event_struct(event));
            code.push('\n');
        }

        // Generate contract binding
        code.push_str(&generate_contract_binding(contract_name, &self.functions));

        code
    }
}

fn generate_event_struct(event: &ParsedEvent) -> String {
    let event_name = &event.name;
    let params_struct_name = format!("{}Params", event_name);
    let event_struct_name = format!("{}Event", event_name);

    let mut code = format!(
        "/// {}({})\n",
        event_name,
        event.inputs.iter().map(|i| format!("{} {}", i.solidity_type, i.name)).collect::<Vec<_>>().join(", ")
    );

    // Params struct
    code.push_str(&format!("pub struct {} {{\n", params_struct_name));
    for input in &event.inputs {
        let rust_type = solidity_to_rust_type(&input.solidity_type);
        code.push_str(&format!("    pub {}: {},\n", to_snake_case(&input.name), rust_type));
    }
    code.push_str("}\n\n");

    // Event type alias using the generic Event<P>
    code.push_str(&format!(
        "pub type {} = Event<{}>;\n\n",
        event_struct_name, params_struct_name
    ));

    // FromAscPtr implementation for the event
    code.push_str(&format!(
        "impl {name} {{\n\
            /// Deserialize from an AscPtr passed by graph-node.\n\
            pub(crate) fn from_asc_ptr(_ptr: u32) -> Self {{\n\
                // TODO: Implement full deserialization from AS memory layout\n\
                unimplemented!(\"Event deserialization not yet implemented\")\n\
            }}\n\
        }}\n",
        name = event_struct_name
    ));

    code
}

fn generate_contract_binding(name: &str, functions: &[ParsedFunction]) -> String {
    let struct_name = to_pascal_case(name);

    let mut code = format!(
        "/// Binding for the {name} contract.\n\
        pub struct {struct_name} {{\n\
            address: Address,\n\
        }}\n\n\
        impl {struct_name} {{\n\
            /// Bind to a deployed contract at the given address.\n\
            pub fn bind(address: Address) -> Self {{\n\
                Self {{ address }}\n\
            }}\n\n",
        name = name,
        struct_name = struct_name
    );

    // Generate method for each view/pure function
    for func in functions {
        if func.state_mutability != "View" && func.state_mutability != "Pure" {
            continue;
        }

        let method_name = to_snake_case(&func.name);
        let return_type = if func.outputs.is_empty() {
            "()".to_string()
        } else if func.outputs.len() == 1 {
            solidity_to_rust_type(&func.outputs[0].solidity_type)
        } else {
            format!(
                "({})",
                func.outputs
                    .iter()
                    .map(|o| solidity_to_rust_type(&o.solidity_type))
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        };

        // Build parameter list
        let params: Vec<String> = func
            .inputs
            .iter()
            .map(|i| format!("{}: {}", to_snake_case(&i.name), solidity_to_rust_type(&i.solidity_type)))
            .collect();

        let params_str = if params.is_empty() {
            "&self".to_string()
        } else {
            format!("&self, {}", params.join(", "))
        };

        // Generate token conversion for each input
        let token_conversions: Vec<String> = func
            .inputs
            .iter()
            .map(|i| {
                let var_name = to_snake_case(&i.name);
                solidity_to_token_conversion(&var_name, &i.solidity_type)
            })
            .collect();

        let tokens_array = if token_conversions.is_empty() {
            "vec![]".to_string()
        } else {
            format!("vec![{}]", token_conversions.join(", "))
        };

        // Generate return value extraction
        let return_extraction = generate_return_extraction(&func.outputs);

        let call_args = func.inputs.iter().map(|i| to_snake_case(&i.name)).collect::<Vec<_>>().join(", ");
        code.push_str(&format!(
            "    /// Call `{func_name}`\n\
            pub fn {method_name}({params_str}) -> Result<{return_type}, String> {{\n\
                use yogurt_runtime::ethereum::{{SmartContractCall, Token, call}};\n\
                \n\
                let call_data = SmartContractCall {{\n\
                    contract_name: \"{contract_name}\".into(),\n\
                    contract_address: self.address.clone(),\n\
                    function_name: \"{func_name}\".into(),\n\
                    function_signature: \"{signature}\".into(),\n\
                    function_params: {tokens_array},\n\
                }};\n\
                \n\
                let result = call(call_data).ok_or_else(|| \"Call reverted\".to_string())?;\n\
                {return_extraction}\n\
            }}\n\n\
            /// Try to call `{func_name}`, returning None on revert.\n\
            pub fn try_{method_name}({params_str}) -> Option<{return_type}> {{\n\
                self.{method_name}({call_args}).ok()\n\
            }}\n\n",
            func_name = func.name,
            method_name = method_name,
            params_str = params_str,
            return_type = return_type,
            contract_name = name,
            signature = func.signature,
            tokens_array = tokens_array,
            return_extraction = return_extraction,
            call_args = call_args
        ));
    }

    code.push_str("}\n");
    code
}

fn solidity_to_rust_type(sol_type: &str) -> String {
    match sol_type {
        "address" => "Address".to_string(),
        "bool" => "bool".to_string(),
        "string" => "String".to_string(),
        "bytes" => "Bytes".to_string(),
        t if t.starts_with("uint") => {
            let bits: u32 = t[4..].parse().unwrap_or(256);
            if bits <= 64 {
                "u64".to_string()
            } else {
                "BigInt".to_string()
            }
        }
        t if t.starts_with("int") => {
            let bits: u32 = t[3..].parse().unwrap_or(256);
            if bits <= 64 {
                "i64".to_string()
            } else {
                "BigInt".to_string()
            }
        }
        t if t.starts_with("bytes") => "Bytes".to_string(),
        t if t.ends_with("[]") => {
            let inner = &t[..t.len() - 2];
            format!("Vec<{}>", solidity_to_rust_type(inner))
        }
        _ => "Bytes".to_string(), // Fallback for unknown types
    }
}

fn to_snake_case(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }

    let mut result = String::with_capacity(s.len() + 4);

    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }

    result
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = true;

    for c in s.chars() {
        if c == '_' || c == '-' || c == ' ' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

/// Generate code to convert a Rust value to a Token.
fn solidity_to_token_conversion(var_name: &str, sol_type: &str) -> String {
    match sol_type {
        "address" => format!("Token::Address({}.clone())", var_name),
        "bool" => format!("Token::Bool({})", var_name),
        "string" => format!("Token::String({}.clone())", var_name),
        "bytes" => format!("Token::Bytes({}.clone())", var_name),
        t if t.starts_with("uint") => format!("Token::Uint({}.clone())", var_name),
        t if t.starts_with("int") => format!("Token::Int({}.clone())", var_name),
        t if t.starts_with("bytes") && t.len() > 5 => {
            // Fixed bytes like bytes32
            format!("Token::FixedBytes({}.as_slice().to_vec())", var_name)
        }
        t if t.ends_with("[]") => {
            let inner = &t[..t.len() - 2];
            format!(
                "Token::Array({}.iter().map(|v| {}).collect())",
                var_name,
                solidity_to_token_conversion("v", inner).replace("v.clone()", "v.clone()")
            )
        }
        _ => format!("Token::Bytes({}.clone())", var_name), // Fallback
    }
}

/// Generate code to extract return values from Token array.
fn generate_return_extraction(outputs: &[FunctionParam]) -> String {
    if outputs.is_empty() {
        return "Ok(())".to_string();
    }

    if outputs.len() == 1 {
        let extraction = token_to_rust_extraction("result.get(0)", &outputs[0].solidity_type);
        return format!(
            "let value = {};\n\
            Ok(value)",
            extraction
        );
    }

    // Multiple outputs - return a tuple
    let extractions: Vec<String> = outputs
        .iter()
        .enumerate()
        .map(|(i, o)| token_to_rust_extraction(&format!("result.get({})", i), &o.solidity_type))
        .collect();

    format!(
        "Ok(({}),)",
        extractions.join(", ")
    )
}

/// Generate code to extract a Rust value from a Token.
fn token_to_rust_extraction(expr: &str, sol_type: &str) -> String {
    match sol_type {
        "address" => format!(
            "match {} {{ Some(Token::Address(a)) => a.clone(), _ => Address::zero() }}",
            expr
        ),
        "bool" => format!(
            "match {} {{ Some(Token::Bool(b)) => *b, _ => false }}",
            expr
        ),
        "string" => format!(
            "match {} {{ Some(Token::String(s)) => s.clone(), _ => String::new() }}",
            expr
        ),
        "bytes" => format!(
            "match {} {{ Some(Token::Bytes(b)) => b.clone(), _ => Bytes::new() }}",
            expr
        ),
        t if t.starts_with("uint") => {
            let bits: u32 = t[4..].parse().unwrap_or(256);
            if bits <= 64 {
                format!(
                    "match {} {{ Some(Token::Uint(n)) => {{ let s = n.to_string(); s.parse::<u64>().unwrap_or(0) }}, _ => 0 }}",
                    expr
                )
            } else {
                format!(
                    "match {} {{ Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() }}",
                    expr
                )
            }
        }
        t if t.starts_with("int") => {
            let bits: u32 = t[3..].parse().unwrap_or(256);
            if bits <= 64 {
                format!(
                    "match {} {{ Some(Token::Int(n)) => {{ let s = n.to_string(); s.parse::<i64>().unwrap_or(0) }}, _ => 0 }}",
                    expr
                )
            } else {
                format!(
                    "match {} {{ Some(Token::Int(n)) => n.clone(), _ => BigInt::zero() }}",
                    expr
                )
            }
        }
        t if t.starts_with("bytes") && t.len() > 5 => {
            format!(
                "match {} {{ Some(Token::FixedBytes(b)) => Bytes::from(b.as_slice()), _ => Bytes::new() }}",
                expr
            )
        }
        _ => format!(
            "match {} {{ Some(Token::Bytes(b)) => b.clone(), _ => Bytes::new() }}",
            expr
        ),
    }
}
