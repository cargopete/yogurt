//! Project initialisation command.

use anyhow::Result;
use console::style;
use dialoguer::{Input, Select};
use std::fs;
use std::path::Path;

pub async fn run(name: Option<String>) -> Result<()> {
    println!("{}", style("yogurt init").bold().cyan());
    println!();

    // Get project name
    let project_name: String = match name {
        Some(n) => n,
        None => Input::new()
            .with_prompt("Project name")
            .interact_text()?,
    };

    // Get protocol
    let protocols = vec!["Ethereum", "Arbitrum", "Optimism", "Polygon", "Base"];
    let protocol_idx = Select::new()
        .with_prompt("Protocol")
        .items(&protocols)
        .default(0)
        .interact()?;
    let protocol = protocols[protocol_idx];

    // Get network
    let networks = match protocol {
        "Ethereum" => vec!["mainnet", "sepolia", "holesky"],
        "Arbitrum" => vec!["arbitrum-one", "arbitrum-sepolia"],
        "Optimism" => vec!["optimism", "optimism-sepolia"],
        "Polygon" => vec!["matic", "mumbai"],
        "Base" => vec!["base", "base-sepolia"],
        _ => vec!["mainnet"],
    };
    let network_idx = Select::new()
        .with_prompt("Network")
        .items(&networks)
        .default(0)
        .interact()?;
    let network = networks[network_idx];

    // Get contract address
    let contract_address: String = Input::new()
        .with_prompt("Contract address")
        .interact_text()?;

    // Get contract name
    let contract_name: String = Input::new()
        .with_prompt("Contract name")
        .default("Contract".into())
        .interact_text()?;

    // Get start block
    let start_block: u64 = Input::new()
        .with_prompt("Start block")
        .default(0)
        .interact_text()?;

    // Create project directory
    let project_dir = Path::new(&project_name);
    fs::create_dir_all(project_dir)?;
    fs::create_dir_all(project_dir.join("src/mappings"))?;
    fs::create_dir_all(project_dir.join("src/generated"))?;
    fs::create_dir_all(project_dir.join("abis"))?;
    fs::create_dir_all(project_dir.join(".cargo"))?;

    // Write subgraph.yaml
    let manifest = format!(
        r#"specVersion: 0.0.9
description: {project_name}
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: {contract_name}
    network: {network}
    source:
      address: "{contract_address}"
      abi: {contract_name}
      startBlock: {start_block}
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.7
      language: wasm/rust
      entities:
        - Entity
      abis:
        - name: {contract_name}
          file: ./abis/{contract_name}.json
      eventHandlers: []
      file: ./build/subgraph.wasm
"#
    );
    fs::write(project_dir.join("subgraph.yaml"), manifest)?;
    println!("  {} Created subgraph.yaml", style("✓").green());

    // Write schema.graphql
    let schema = r#"type Entity @entity {
  id: ID!
}
"#;
    fs::write(project_dir.join("schema.graphql"), schema)?;
    println!("  {} Created schema.graphql", style("✓").green());

    // Write Cargo.toml
    let cargo_toml = format!(
        r#"[package]
name = "{project_name}"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]
yogurt-runtime = "0.1"
yogurt-macros = "0.1"

[profile.release]
opt-level = "z"
lto = true
strip = true
panic = "abort"
codegen-units = 1
"#
    );
    fs::write(project_dir.join("Cargo.toml"), cargo_toml)?;
    println!("  {} Created Cargo.toml", style("✓").green());

    // Write .cargo/config.toml
    let cargo_config = r#"[build]
target = "wasm32-unknown-unknown"

[target.wasm32-unknown-unknown]
rustflags = [
    "-C", "link-args=-z stack-size=65536",
]
"#;
    fs::write(project_dir.join(".cargo/config.toml"), cargo_config)?;
    println!("  {} Created .cargo/config.toml", style("✓").green());

    // Write src/lib.rs
    let lib_rs = r#"#![no_std]
extern crate alloc;

mod generated;
mod mappings;
"#;
    fs::write(project_dir.join("src/lib.rs"), lib_rs)?;
    println!("  {} Created src/lib.rs", style("✓").green());

    // Write src/mappings/mod.rs
    let mappings_mod = r#"//! Subgraph mapping handlers.
//!
//! Add your event handlers here.

use yogurt_runtime::prelude::*;
"#;
    fs::write(project_dir.join("src/mappings/mod.rs"), mappings_mod)?;
    println!("  {} Created src/mappings/mod.rs", style("✓").green());

    // Write placeholder ABI
    let placeholder_abi = "[]";
    fs::write(
        project_dir.join(format!("abis/{}.json", contract_name)),
        placeholder_abi,
    )?;
    println!(
        "  {} Created abis/{}.json (placeholder)",
        style("✓").green(),
        contract_name
    );

    // Write generated placeholder
    let generated_mod = "//! Auto-generated by yogurt codegen — run `yogurt codegen` to populate\n";
    fs::write(project_dir.join("src/generated/mod.rs"), generated_mod)?;
    println!("  {} Created src/generated/mod.rs", style("✓").green());

    // Write .gitignore
    let gitignore = r#"/target
/build
Cargo.lock
"#;
    fs::write(project_dir.join(".gitignore"), gitignore)?;
    println!("  {} Created .gitignore", style("✓").green());

    println!();
    println!("{}", style("Project initialised!").bold().green());
    println!();
    println!("Next steps:");
    println!(
        "  {} {}",
        style("cd").cyan(),
        style(&project_name).yellow()
    );
    println!(
        "  {} # Generate types from schema & ABIs",
        style("yogurt codegen").cyan()
    );
    println!(
        "  {} # Compile to WASM",
        style("yogurt build").cyan()
    );

    Ok(())
}
