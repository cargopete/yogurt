//! Auto-generated by yogurt codegen — do not edit

#[allow(unused_imports)]
use alloc::string::String;
#[allow(unused_imports)]
use alloc::string::ToString;
#[allow(unused_imports)]
use alloc::vec::Vec;
use yogurt_runtime::prelude::*;
use yogurt_runtime::store;
use yogurt_runtime::types::{EntityData, Value};

pub struct Factory {
    data: EntityData,
}

impl Factory {
pub fn new(id: impl Into<String>) -> Self {
let mut data = EntityData::new();
data.set("id", Value::String(id.into()));
Self { data }
}

    pub fn id(&self) -> &str {
        self.data.get_string("id")
    }

    pub fn pair_count(&self) -> BigInt {
        self.data.get_bigint("pairCount")
    }

    pub fn total_volume_eth(&self) -> BigDecimal {
        self.data.get_big_decimal("totalVolumeETH")
    }

    pub fn total_liquidity_eth(&self) -> BigDecimal {
        self.data.get_big_decimal("totalLiquidityETH")
    }

    pub fn set_pair_count(&mut self, val: impl Into<BigInt>) {
        self.data.set("pairCount", Value::BigInt(val.into()));
    }

    pub fn set_total_volume_eth(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("totalVolumeETH", Value::BigDecimal(val.into()));
    }

    pub fn set_total_liquidity_eth(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("totalLiquidityETH", Value::BigDecimal(val.into()));
    }

}

impl Entity for Factory {
const ENTITY_TYPE: &'static str = "Factory";

fn id(&self) -> &str {
self.data.get_string("id")
}

fn save(&self) {
store::set(Self::ENTITY_TYPE, self.id(), &self.data);
}

fn load(id: &str) -> Option<Self> {
store::get(Self::ENTITY_TYPE, id).map(|data| Self { data })
}

fn remove(id: &str) {
store::remove(Self::ENTITY_TYPE, id);
}
}

pub struct Token {
    data: EntityData,
}

impl Token {
pub fn new(id: impl Into<String>) -> Self {
let mut data = EntityData::new();
data.set("id", Value::String(id.into()));
Self { data }
}

    pub fn id(&self) -> &str {
        self.data.get_string("id")
    }

    pub fn symbol(&self) -> &str {
        self.data.get_string("symbol")
    }

    pub fn name(&self) -> &str {
        self.data.get_string("name")
    }

    pub fn decimals(&self) -> BigInt {
        self.data.get_bigint("decimals")
    }

    pub fn total_supply(&self) -> BigInt {
        self.data.get_bigint("totalSupply")
    }

    pub fn trade_volume(&self) -> BigDecimal {
        self.data.get_big_decimal("tradeVolume")
    }

    pub fn tx_count(&self) -> BigInt {
        self.data.get_bigint("txCount")
    }

    pub fn set_symbol(&mut self, val: impl Into<String>) {
        self.data.set("symbol", Value::String(val.into()));
    }

    pub fn set_name(&mut self, val: impl Into<String>) {
        self.data.set("name", Value::String(val.into()));
    }

    pub fn set_decimals(&mut self, val: impl Into<BigInt>) {
        self.data.set("decimals", Value::BigInt(val.into()));
    }

    pub fn set_total_supply(&mut self, val: impl Into<BigInt>) {
        self.data.set("totalSupply", Value::BigInt(val.into()));
    }

    pub fn set_trade_volume(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("tradeVolume", Value::BigDecimal(val.into()));
    }

    pub fn set_tx_count(&mut self, val: impl Into<BigInt>) {
        self.data.set("txCount", Value::BigInt(val.into()));
    }

}

impl Entity for Token {
const ENTITY_TYPE: &'static str = "Token";

fn id(&self) -> &str {
self.data.get_string("id")
}

fn save(&self) {
store::set(Self::ENTITY_TYPE, self.id(), &self.data);
}

fn load(id: &str) -> Option<Self> {
store::get(Self::ENTITY_TYPE, id).map(|data| Self { data })
}

fn remove(id: &str) {
store::remove(Self::ENTITY_TYPE, id);
}
}

pub struct Pair {
    data: EntityData,
}

impl Pair {
pub fn new(id: impl Into<String>) -> Self {
let mut data = EntityData::new();
data.set("id", Value::String(id.into()));
Self { data }
}

    pub fn id(&self) -> &str {
        self.data.get_string("id")
    }

    pub fn token0(&self) -> String {
        self.data.get_string("token0").to_string()
    }

    pub fn token1(&self) -> String {
        self.data.get_string("token1").to_string()
    }

    pub fn reserve0(&self) -> BigDecimal {
        self.data.get_big_decimal("reserve0")
    }

    pub fn reserve1(&self) -> BigDecimal {
        self.data.get_big_decimal("reserve1")
    }

    pub fn total_supply(&self) -> BigDecimal {
        self.data.get_big_decimal("totalSupply")
    }

    pub fn tx_count(&self) -> BigInt {
        self.data.get_bigint("txCount")
    }

    pub fn created_at_timestamp(&self) -> BigInt {
        self.data.get_bigint("createdAtTimestamp")
    }

    pub fn created_at_block_number(&self) -> BigInt {
        self.data.get_bigint("createdAtBlockNumber")
    }

    pub fn set_token0(&mut self, val: impl Into<String>) {
        self.data.set("token0", Value::String(val.into()));
    }

    pub fn set_token1(&mut self, val: impl Into<String>) {
        self.data.set("token1", Value::String(val.into()));
    }

    pub fn set_reserve0(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("reserve0", Value::BigDecimal(val.into()));
    }

    pub fn set_reserve1(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("reserve1", Value::BigDecimal(val.into()));
    }

    pub fn set_total_supply(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("totalSupply", Value::BigDecimal(val.into()));
    }

    pub fn set_tx_count(&mut self, val: impl Into<BigInt>) {
        self.data.set("txCount", Value::BigInt(val.into()));
    }

    pub fn set_created_at_timestamp(&mut self, val: impl Into<BigInt>) {
        self.data.set("createdAtTimestamp", Value::BigInt(val.into()));
    }

    pub fn set_created_at_block_number(&mut self, val: impl Into<BigInt>) {
        self.data.set("createdAtBlockNumber", Value::BigInt(val.into()));
    }

}

impl Entity for Pair {
const ENTITY_TYPE: &'static str = "Pair";

fn id(&self) -> &str {
self.data.get_string("id")
}

fn save(&self) {
store::set(Self::ENTITY_TYPE, self.id(), &self.data);
}

fn load(id: &str) -> Option<Self> {
store::get(Self::ENTITY_TYPE, id).map(|data| Self { data })
}

fn remove(id: &str) {
store::remove(Self::ENTITY_TYPE, id);
}
}

/// Immutable entity — cannot be updated after first save (enforced by graph-node).
pub struct Swap {
    data: EntityData,
}

impl Swap {
pub fn new(id: impl Into<String>) -> Self {
let mut data = EntityData::new();
data.set("id", Value::String(id.into()));
Self { data }
}

    pub fn id(&self) -> &str {
        self.data.get_string("id")
    }

    pub fn pair(&self) -> String {
        self.data.get_string("pair").to_string()
    }

    pub fn timestamp(&self) -> BigInt {
        self.data.get_bigint("timestamp")
    }

    pub fn sender(&self) -> Bytes {
        self.data.get_bytes("sender")
    }

    pub fn amount0_in(&self) -> BigDecimal {
        self.data.get_big_decimal("amount0In")
    }

    pub fn amount1_in(&self) -> BigDecimal {
        self.data.get_big_decimal("amount1In")
    }

    pub fn amount0_out(&self) -> BigDecimal {
        self.data.get_big_decimal("amount0Out")
    }

    pub fn amount1_out(&self) -> BigDecimal {
        self.data.get_big_decimal("amount1Out")
    }

    pub fn to(&self) -> Bytes {
        self.data.get_bytes("to")
    }

    pub fn log_index(&self) -> BigInt {
        self.data.get_bigint("logIndex")
    }

    pub fn transaction(&self) -> Bytes {
        self.data.get_bytes("transaction")
    }

    pub fn set_pair(&mut self, val: impl Into<String>) {
        self.data.set("pair", Value::String(val.into()));
    }

    pub fn set_timestamp(&mut self, val: impl Into<BigInt>) {
        self.data.set("timestamp", Value::BigInt(val.into()));
    }

    pub fn set_sender(&mut self, val: impl Into<Bytes>) {
        self.data.set("sender", Value::Bytes(val.into()));
    }

    pub fn set_amount0_in(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount0In", Value::BigDecimal(val.into()));
    }

    pub fn set_amount1_in(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount1In", Value::BigDecimal(val.into()));
    }

    pub fn set_amount0_out(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount0Out", Value::BigDecimal(val.into()));
    }

    pub fn set_amount1_out(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount1Out", Value::BigDecimal(val.into()));
    }

    pub fn set_to(&mut self, val: impl Into<Bytes>) {
        self.data.set("to", Value::Bytes(val.into()));
    }

    pub fn set_log_index(&mut self, val: impl Into<BigInt>) {
        self.data.set("logIndex", Value::BigInt(val.into()));
    }

    pub fn set_transaction(&mut self, val: impl Into<Bytes>) {
        self.data.set("transaction", Value::Bytes(val.into()));
    }

}

impl Entity for Swap {
const ENTITY_TYPE: &'static str = "Swap";

fn id(&self) -> &str {
self.data.get_string("id")
}

fn save(&self) {
store::set(Self::ENTITY_TYPE, self.id(), &self.data);
}

fn load(id: &str) -> Option<Self> {
store::get(Self::ENTITY_TYPE, id).map(|data| Self { data })
}

fn remove(id: &str) {
store::remove(Self::ENTITY_TYPE, id);
}
}

/// Immutable entity — cannot be updated after first save (enforced by graph-node).
pub struct Mint {
    data: EntityData,
}

impl Mint {
pub fn new(id: impl Into<String>) -> Self {
let mut data = EntityData::new();
data.set("id", Value::String(id.into()));
Self { data }
}

    pub fn id(&self) -> &str {
        self.data.get_string("id")
    }

    pub fn pair(&self) -> String {
        self.data.get_string("pair").to_string()
    }

    pub fn timestamp(&self) -> BigInt {
        self.data.get_bigint("timestamp")
    }

    pub fn sender(&self) -> Bytes {
        self.data.get_bytes("sender")
    }

    pub fn amount0(&self) -> BigDecimal {
        self.data.get_big_decimal("amount0")
    }

    pub fn amount1(&self) -> BigDecimal {
        self.data.get_big_decimal("amount1")
    }

    pub fn to(&self) -> Bytes {
        self.data.get_bytes("to")
    }

    pub fn log_index(&self) -> BigInt {
        self.data.get_bigint("logIndex")
    }

    pub fn transaction(&self) -> Bytes {
        self.data.get_bytes("transaction")
    }

    pub fn set_pair(&mut self, val: impl Into<String>) {
        self.data.set("pair", Value::String(val.into()));
    }

    pub fn set_timestamp(&mut self, val: impl Into<BigInt>) {
        self.data.set("timestamp", Value::BigInt(val.into()));
    }

    pub fn set_sender(&mut self, val: impl Into<Bytes>) {
        self.data.set("sender", Value::Bytes(val.into()));
    }

    pub fn set_amount0(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount0", Value::BigDecimal(val.into()));
    }

    pub fn set_amount1(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount1", Value::BigDecimal(val.into()));
    }

    pub fn set_to(&mut self, val: impl Into<Bytes>) {
        self.data.set("to", Value::Bytes(val.into()));
    }

    pub fn set_log_index(&mut self, val: impl Into<BigInt>) {
        self.data.set("logIndex", Value::BigInt(val.into()));
    }

    pub fn set_transaction(&mut self, val: impl Into<Bytes>) {
        self.data.set("transaction", Value::Bytes(val.into()));
    }

}

impl Entity for Mint {
const ENTITY_TYPE: &'static str = "Mint";

fn id(&self) -> &str {
self.data.get_string("id")
}

fn save(&self) {
store::set(Self::ENTITY_TYPE, self.id(), &self.data);
}

fn load(id: &str) -> Option<Self> {
store::get(Self::ENTITY_TYPE, id).map(|data| Self { data })
}

fn remove(id: &str) {
store::remove(Self::ENTITY_TYPE, id);
}
}

/// Immutable entity — cannot be updated after first save (enforced by graph-node).
pub struct Burn {
    data: EntityData,
}

impl Burn {
pub fn new(id: impl Into<String>) -> Self {
let mut data = EntityData::new();
data.set("id", Value::String(id.into()));
Self { data }
}

    pub fn id(&self) -> &str {
        self.data.get_string("id")
    }

    pub fn pair(&self) -> String {
        self.data.get_string("pair").to_string()
    }

    pub fn timestamp(&self) -> BigInt {
        self.data.get_bigint("timestamp")
    }

    pub fn sender(&self) -> Bytes {
        self.data.get_bytes("sender")
    }

    pub fn amount0(&self) -> BigDecimal {
        self.data.get_big_decimal("amount0")
    }

    pub fn amount1(&self) -> BigDecimal {
        self.data.get_big_decimal("amount1")
    }

    pub fn to(&self) -> Bytes {
        self.data.get_bytes("to")
    }

    pub fn log_index(&self) -> BigInt {
        self.data.get_bigint("logIndex")
    }

    pub fn transaction(&self) -> Bytes {
        self.data.get_bytes("transaction")
    }

    pub fn set_pair(&mut self, val: impl Into<String>) {
        self.data.set("pair", Value::String(val.into()));
    }

    pub fn set_timestamp(&mut self, val: impl Into<BigInt>) {
        self.data.set("timestamp", Value::BigInt(val.into()));
    }

    pub fn set_sender(&mut self, val: impl Into<Bytes>) {
        self.data.set("sender", Value::Bytes(val.into()));
    }

    pub fn set_amount0(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount0", Value::BigDecimal(val.into()));
    }

    pub fn set_amount1(&mut self, val: impl Into<BigDecimal>) {
        self.data.set("amount1", Value::BigDecimal(val.into()));
    }

    pub fn set_to(&mut self, val: impl Into<Bytes>) {
        self.data.set("to", Value::Bytes(val.into()));
    }

    pub fn set_log_index(&mut self, val: impl Into<BigInt>) {
        self.data.set("logIndex", Value::BigInt(val.into()));
    }

    pub fn set_transaction(&mut self, val: impl Into<Bytes>) {
        self.data.set("transaction", Value::Bytes(val.into()));
    }

}

impl Entity for Burn {
const ENTITY_TYPE: &'static str = "Burn";

fn id(&self) -> &str {
self.data.get_string("id")
}

fn save(&self) {
store::set(Self::ENTITY_TYPE, self.id(), &self.data);
}

fn load(id: &str) -> Option<Self> {
store::get(Self::ENTITY_TYPE, id).map(|data| Self { data })
}

fn remove(id: &str) {
store::remove(Self::ENTITY_TYPE, id);
}
}

