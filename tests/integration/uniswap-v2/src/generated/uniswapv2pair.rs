//! Auto-generated by yogurt codegen â€” do not edit

#[allow(unused_imports)]
use alloc::string::{String, ToString};
#[allow(unused_imports)]
use alloc::vec;
#[allow(unused_imports)]
use alloc::vec::Vec;
use yogurt_runtime::prelude::*;
use yogurt_runtime::ethereum::{Call, Event, SmartContractCall, Token};

/// Burn(address sender, uint256 amount0, uint256 amount1, address to)
pub struct BurnParams {
    pub sender: Address,
    pub amount0: BigInt,
    pub amount1: BigInt,
    pub to: Address,
}

pub type BurnEvent = Event<BurnParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for BurnParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let sender_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let sender_bytes = asc_to_bytes(AscPtr::new(sender_value_ptr));
let sender = Address::from(sender_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let amount0_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount0 = BigInt::from_ptr(AscPtr::new(amount0_value_ptr));

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let amount1_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount1 = BigInt::from_ptr(AscPtr::new(amount1_value_ptr));

                    let param3_ptr = read_u32_at(buffer_ptr, 12);
let to_value_ptr = read_u32_at(param3_ptr, EVENT_PARAM_VALUE_OFFSET);
let to_bytes = asc_to_bytes(AscPtr::new(to_value_ptr));
let to = Address::from(to_bytes.as_slice());

Self { sender, amount0, amount1, to }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for BurnParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for BurnParams {
fn default() -> Self {
Self {
                    sender: Address::zero(),
                    amount0: BigInt::zero(),
                    amount1: BigInt::zero(),
                    to: Address::zero(),
}
}
}

/// Mint(address sender, uint256 amount0, uint256 amount1)
pub struct MintParams {
    pub sender: Address,
    pub amount0: BigInt,
    pub amount1: BigInt,
}

pub type MintEvent = Event<MintParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for MintParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let sender_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let sender_bytes = asc_to_bytes(AscPtr::new(sender_value_ptr));
let sender = Address::from(sender_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let amount0_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount0 = BigInt::from_ptr(AscPtr::new(amount0_value_ptr));

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let amount1_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount1 = BigInt::from_ptr(AscPtr::new(amount1_value_ptr));

Self { sender, amount0, amount1 }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for MintParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for MintParams {
fn default() -> Self {
Self {
                    sender: Address::zero(),
                    amount0: BigInt::zero(),
                    amount1: BigInt::zero(),
}
}
}

/// Swap(address sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address to)
pub struct SwapParams {
    pub sender: Address,
    pub amount0_in: BigInt,
    pub amount1_in: BigInt,
    pub amount0_out: BigInt,
    pub amount1_out: BigInt,
    pub to: Address,
}

pub type SwapEvent = Event<SwapParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for SwapParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let sender_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let sender_bytes = asc_to_bytes(AscPtr::new(sender_value_ptr));
let sender = Address::from(sender_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let amount0_in_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount0_in = BigInt::from_ptr(AscPtr::new(amount0_in_value_ptr));

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let amount1_in_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount1_in = BigInt::from_ptr(AscPtr::new(amount1_in_value_ptr));

                    let param3_ptr = read_u32_at(buffer_ptr, 12);
let amount0_out_value_ptr = read_u32_at(param3_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount0_out = BigInt::from_ptr(AscPtr::new(amount0_out_value_ptr));

                    let param4_ptr = read_u32_at(buffer_ptr, 16);
let amount1_out_value_ptr = read_u32_at(param4_ptr, EVENT_PARAM_VALUE_OFFSET);
let amount1_out = BigInt::from_ptr(AscPtr::new(amount1_out_value_ptr));

                    let param5_ptr = read_u32_at(buffer_ptr, 20);
let to_value_ptr = read_u32_at(param5_ptr, EVENT_PARAM_VALUE_OFFSET);
let to_bytes = asc_to_bytes(AscPtr::new(to_value_ptr));
let to = Address::from(to_bytes.as_slice());

Self { sender, amount0_in, amount1_in, amount0_out, amount1_out, to }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for SwapParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for SwapParams {
fn default() -> Self {
Self {
                    sender: Address::zero(),
                    amount0_in: BigInt::zero(),
                    amount1_in: BigInt::zero(),
                    amount0_out: BigInt::zero(),
                    amount1_out: BigInt::zero(),
                    to: Address::zero(),
}
}
}

/// Sync(uint112 reserve0, uint112 reserve1)
pub struct SyncParams {
    pub reserve0: BigInt,
    pub reserve1: BigInt,
}

pub type SyncEvent = Event<SyncParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for SyncParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let reserve0_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let reserve0 = BigInt::from_ptr(AscPtr::new(reserve0_value_ptr));

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let reserve1_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let reserve1 = BigInt::from_ptr(AscPtr::new(reserve1_value_ptr));

Self { reserve0, reserve1 }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for SyncParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for SyncParams {
fn default() -> Self {
Self {
                    reserve0: BigInt::zero(),
                    reserve1: BigInt::zero(),
}
}
}

/// Transfer(address from, address to, uint256 value)
pub struct TransferParams {
    pub from: Address,
    pub to: Address,
    pub value: BigInt,
}

pub type TransferEvent = Event<TransferParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for TransferParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let from_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let from_bytes = asc_to_bytes(AscPtr::new(from_value_ptr));
let from = Address::from(from_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let to_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let to_bytes = asc_to_bytes(AscPtr::new(to_value_ptr));
let to = Address::from(to_bytes.as_slice());

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let value_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let value = BigInt::from_ptr(AscPtr::new(value_value_ptr));

Self { from, to, value }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for TransferParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for TransferParams {
fn default() -> Self {
Self {
                    from: Address::zero(),
                    to: Address::zero(),
                    value: BigInt::zero(),
}
}
}

/// Binding for the UniswapV2Pair contract.
pub struct UniswapV2Pair {
address: Address,
}

impl UniswapV2Pair {
/// Bind to a deployed contract at the given address.
pub fn bind(address: Address) -> Self {
Self { address }
}

    /// Call `factory`
pub fn factory(&self) -> Result<Address, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Pair".into(),
contract_address: self.address.clone(),
function_name: "factory".into(),
function_signature: "factory()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Address(a)) => a.clone(), _ => Address::zero() };
Ok(value)
}

/// Try to call `factory`, returning None on revert.
pub fn try_factory(&self) -> Option<Address> {
self.factory().ok()
}

    /// Call `getReserves`
pub fn get_reserves(&self) -> Result<(BigInt, BigInt, u64), String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Pair".into(),
contract_address: self.address.clone(),
function_name: "getReserves".into(),
function_signature: "getReserves()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
Ok((match result.get(0) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() }, match result.get(1) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() }, match result.get(2) { Some(Token::Uint(n)) => { let s = n.to_string(); s.parse::<u64>().unwrap_or(0) }, _ => 0 }),)
}

/// Try to call `getReserves`, returning None on revert.
pub fn try_get_reserves(&self) -> Option<(BigInt, BigInt, u64)> {
self.get_reserves().ok()
}

    /// Call `token0`
pub fn token0(&self) -> Result<Address, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Pair".into(),
contract_address: self.address.clone(),
function_name: "token0".into(),
function_signature: "token0()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Address(a)) => a.clone(), _ => Address::zero() };
Ok(value)
}

/// Try to call `token0`, returning None on revert.
pub fn try_token0(&self) -> Option<Address> {
self.token0().ok()
}

    /// Call `token1`
pub fn token1(&self) -> Result<Address, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Pair".into(),
contract_address: self.address.clone(),
function_name: "token1".into(),
function_signature: "token1()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Address(a)) => a.clone(), _ => Address::zero() };
Ok(value)
}

/// Try to call `token1`, returning None on revert.
pub fn try_token1(&self) -> Option<Address> {
self.token1().ok()
}

    /// Call `totalSupply`
pub fn total_supply(&self) -> Result<BigInt, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Pair".into(),
contract_address: self.address.clone(),
function_name: "totalSupply".into(),
function_signature: "totalSupply()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() };
Ok(value)
}

/// Try to call `totalSupply`, returning None on revert.
pub fn try_total_supply(&self) -> Option<BigInt> {
self.total_supply().ok()
}

}
