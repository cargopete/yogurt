//! Auto-generated by yogurt codegen â€” do not edit

#[allow(unused_imports)]
use alloc::string::{String, ToString};
#[allow(unused_imports)]
use alloc::vec;
#[allow(unused_imports)]
use alloc::vec::Vec;
use yogurt_runtime::prelude::*;
use yogurt_runtime::ethereum::{Call, Event, SmartContractCall, Token};

/// Binding for the ERC20 contract.
pub struct ERC20 {
address: Address,
}

impl ERC20 {
/// Bind to a deployed contract at the given address.
pub fn bind(address: Address) -> Self {
Self { address }
}

    /// Call `decimals`
pub fn decimals(&self) -> Result<u64, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "decimals".into(),
function_signature: "decimals()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => { let s = n.to_string(); s.parse::<u64>().unwrap_or(0) }, _ => 0 };
Ok(value)
}

/// Try to call `decimals`, returning None on revert.
pub fn try_decimals(&self) -> Option<u64> {
self.decimals().ok()
}

    /// Call `name`
pub fn name(&self) -> Result<String, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "name".into(),
function_signature: "name()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::String(s)) => s.clone(), _ => String::new() };
Ok(value)
}

/// Try to call `name`, returning None on revert.
pub fn try_name(&self) -> Option<String> {
self.name().ok()
}

    /// Call `symbol`
pub fn symbol(&self) -> Result<String, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "symbol".into(),
function_signature: "symbol()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::String(s)) => s.clone(), _ => String::new() };
Ok(value)
}

/// Try to call `symbol`, returning None on revert.
pub fn try_symbol(&self) -> Option<String> {
self.symbol().ok()
}

    /// Call `totalSupply`
pub fn total_supply(&self) -> Result<BigInt, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "totalSupply".into(),
function_signature: "totalSupply()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() };
Ok(value)
}

/// Try to call `totalSupply`, returning None on revert.
pub fn try_total_supply(&self) -> Option<BigInt> {
self.total_supply().ok()
}

}
