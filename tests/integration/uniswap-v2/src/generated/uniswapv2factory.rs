//! Auto-generated by yogurt codegen â€” do not edit

#[allow(unused_imports)]
use alloc::string::{String, ToString};
#[allow(unused_imports)]
use alloc::vec;
#[allow(unused_imports)]
use alloc::vec::Vec;
use yogurt_runtime::prelude::*;
use yogurt_runtime::ethereum::{Call, Event, SmartContractCall, Token};

/// PairCreated(address token0, address token1, address pair, uint256 pairIndex)
pub struct PairCreatedParams {
    pub token0: Address,
    pub token1: Address,
    pub pair: Address,
    pub pair_index: BigInt,
}

pub type PairCreatedEvent = Event<PairCreatedParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for PairCreatedParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let token0_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let token0_bytes = asc_to_bytes(AscPtr::new(token0_value_ptr));
let token0 = Address::from(token0_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let token1_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let token1_bytes = asc_to_bytes(AscPtr::new(token1_value_ptr));
let token1 = Address::from(token1_bytes.as_slice());

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let pair_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let pair_bytes = asc_to_bytes(AscPtr::new(pair_value_ptr));
let pair = Address::from(pair_bytes.as_slice());

                    let param3_ptr = read_u32_at(buffer_ptr, 12);
let pair_index_value_ptr = read_u32_at(param3_ptr, EVENT_PARAM_VALUE_OFFSET);
let pair_index = BigInt::from_ptr(AscPtr::new(pair_index_value_ptr));

Self { token0, token1, pair, pair_index }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for PairCreatedParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for PairCreatedParams {
fn default() -> Self {
Self {
                    token0: Address::zero(),
                    token1: Address::zero(),
                    pair: Address::zero(),
                    pair_index: BigInt::zero(),
}
}
}

/// Binding for the UniswapV2Factory contract.
pub struct UniswapV2Factory {
address: Address,
}

impl UniswapV2Factory {
/// Bind to a deployed contract at the given address.
pub fn bind(address: Address) -> Self {
Self { address }
}

    /// Call `allPairs`
pub fn all_pairs(&self, param0: BigInt) -> Result<Address, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Factory".into(),
contract_address: self.address.clone(),
function_name: "allPairs".into(),
function_signature: "allPairs(uint256)".into(),
function_params: vec![Token::Uint(param0.clone())],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Address(a)) => a.clone(), _ => Address::zero() };
Ok(value)
}

/// Try to call `allPairs`, returning None on revert.
pub fn try_all_pairs(&self, param0: BigInt) -> Option<Address> {
self.all_pairs(param0).ok()
}

    /// Call `allPairsLength`
pub fn all_pairs_length(&self) -> Result<BigInt, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Factory".into(),
contract_address: self.address.clone(),
function_name: "allPairsLength".into(),
function_signature: "allPairsLength()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() };
Ok(value)
}

/// Try to call `allPairsLength`, returning None on revert.
pub fn try_all_pairs_length(&self) -> Option<BigInt> {
self.all_pairs_length().ok()
}

    /// Call `getPair`
pub fn get_pair(&self, param0: Address, param1: Address) -> Result<Address, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "UniswapV2Factory".into(),
contract_address: self.address.clone(),
function_name: "getPair".into(),
function_signature: "getPair(address,address)".into(),
function_params: vec![Token::Address(param0.clone()), Token::Address(param1.clone())],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Address(a)) => a.clone(), _ => Address::zero() };
Ok(value)
}

/// Try to call `getPair`, returning None on revert.
pub fn try_get_pair(&self, param0: Address, param1: Address) -> Option<Address> {
self.get_pair(param0, param1).ok()
}

}
