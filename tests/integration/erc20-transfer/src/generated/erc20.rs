//! Auto-generated by yogurt codegen â€” do not edit

#[allow(unused_imports)]
use alloc::string::{String, ToString};
#[allow(unused_imports)]
use alloc::vec;
#[allow(unused_imports)]
use alloc::vec::Vec;
use yogurt_runtime::prelude::*;
use yogurt_runtime::ethereum::{Call, Event, SmartContractCall, Token};

/// Approval(address owner, address spender, uint256 value)
pub struct ApprovalParams {
    pub owner: Address,
    pub spender: Address,
    pub value: BigInt,
}

pub type ApprovalEvent = Event<ApprovalParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for ApprovalParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let owner_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let owner_bytes = asc_to_bytes(AscPtr::new(owner_value_ptr));
let owner = Address::from(owner_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let spender_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let spender_bytes = asc_to_bytes(AscPtr::new(spender_value_ptr));
let spender = Address::from(spender_bytes.as_slice());

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let value_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let value = BigInt::from_ptr(AscPtr::new(value_value_ptr));

Self { owner, spender, value }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for ApprovalParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for ApprovalParams {
fn default() -> Self {
Self {
                    owner: Address::zero(),
                    spender: Address::zero(),
                    value: BigInt::zero(),
}
}
}

/// Transfer(address from, address to, uint256 value)
pub struct TransferParams {
    pub from: Address,
    pub to: Address,
    pub value: BigInt,
}

pub type TransferEvent = Event<TransferParams>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for TransferParams {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let from_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let from_bytes = asc_to_bytes(AscPtr::new(from_value_ptr));
let from = Address::from(from_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let to_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let to_bytes = asc_to_bytes(AscPtr::new(to_value_ptr));
let to = Address::from(to_bytes.as_slice());

                    let param2_ptr = read_u32_at(buffer_ptr, 8);
let value_value_ptr = read_u32_at(param2_ptr, EVENT_PARAM_VALUE_OFFSET);
let value = BigInt::from_ptr(AscPtr::new(value_value_ptr));

Self { from, to, value }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for TransferParams {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for TransferParams {
fn default() -> Self {
Self {
                    from: Address::zero(),
                    to: Address::zero(),
                    value: BigInt::zero(),
}
}
}

/// Call handler types for `transfer(address,uint256)`
pub struct TransferInputs {
    pub to: Address,
    pub value: BigInt,
}

pub struct TransferOutputs {
    pub output0: bool,
}

pub type TransferCall = Call<TransferInputs, TransferOutputs>;

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for TransferInputs {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let to_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let to_bytes = asc_to_bytes(AscPtr::new(to_value_ptr));
let to = Address::from(to_bytes.as_slice());

                    let param1_ptr = read_u32_at(buffer_ptr, 4);
let value_value_ptr = read_u32_at(param1_ptr, EVENT_PARAM_VALUE_OFFSET);
let value = BigInt::from_ptr(AscPtr::new(value_value_ptr));

Self { to, value }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for TransferInputs {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for TransferInputs {
fn default() -> Self {
Self {
                    to: Address::zero(),
                    value: BigInt::zero(),
}
}
}

#[cfg(target_arch = "wasm32")]
impl FromAscPtr for TransferOutputs {
fn from_asc_ptr(ptr: u32) -> Self {
use yogurt_runtime::asc::{asc_to_bytes, read_u32_at, AscArrayHeader, AscPtr};

if ptr == 0 {
return Self::default();
}

unsafe {
// ptr points to Array<EventParam>
let array_header = ptr as *const AscArrayHeader;
let buffer_ptr = (*array_header).buffer;

// EventParam layout: name (offset 0), value (offset 4)
const EVENT_PARAM_VALUE_OFFSET: usize = 4;

                    let param0_ptr = read_u32_at(buffer_ptr, 0);
let output0_value_ptr = read_u32_at(param0_ptr, EVENT_PARAM_VALUE_OFFSET);
let output0 = output0_value_ptr != 0;

Self { output0 }
}
}
}

#[cfg(not(target_arch = "wasm32"))]
impl FromAscPtr for TransferOutputs {
fn from_asc_ptr(_ptr: u32) -> Self {
Self::default()
}
}

impl Default for TransferOutputs {
fn default() -> Self {
Self {
                    output0: false,
}
}
}

/// Binding for the ERC20 contract.
pub struct ERC20 {
address: Address,
}

impl ERC20 {
/// Bind to a deployed contract at the given address.
pub fn bind(address: Address) -> Self {
Self { address }
}

    /// Call `balanceOf`
pub fn balance_of(&self, owner: Address) -> Result<BigInt, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "balanceOf".into(),
function_signature: "balanceOf(address)".into(),
function_params: vec![Token::Address(owner.clone())],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() };
Ok(value)
}

/// Try to call `balanceOf`, returning None on revert.
pub fn try_balance_of(&self, owner: Address) -> Option<BigInt> {
self.balance_of(owner).ok()
}

    /// Call `decimals`
pub fn decimals(&self) -> Result<u64, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "decimals".into(),
function_signature: "decimals()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => { let s = n.to_string(); s.parse::<u64>().unwrap_or(0) }, _ => 0 };
Ok(value)
}

/// Try to call `decimals`, returning None on revert.
pub fn try_decimals(&self) -> Option<u64> {
self.decimals().ok()
}

    /// Call `name`
pub fn name(&self) -> Result<String, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "name".into(),
function_signature: "name()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::String(s)) => s.clone(), _ => String::new() };
Ok(value)
}

/// Try to call `name`, returning None on revert.
pub fn try_name(&self) -> Option<String> {
self.name().ok()
}

    /// Call `symbol`
pub fn symbol(&self) -> Result<String, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "symbol".into(),
function_signature: "symbol()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::String(s)) => s.clone(), _ => String::new() };
Ok(value)
}

/// Try to call `symbol`, returning None on revert.
pub fn try_symbol(&self) -> Option<String> {
self.symbol().ok()
}

    /// Call `totalSupply`
pub fn total_supply(&self) -> Result<BigInt, String> {
use yogurt_runtime::ethereum::{SmartContractCall, Token, call};

let call_data = SmartContractCall {
contract_name: "ERC20".into(),
contract_address: self.address.clone(),
function_name: "totalSupply".into(),
function_signature: "totalSupply()".into(),
function_params: vec![],
};

let result = call(call_data).ok_or_else(|| "Call reverted".to_string())?;
let value = match result.get(0) { Some(Token::Uint(n)) => n.clone(), _ => BigInt::zero() };
Ok(value)
}

/// Try to call `totalSupply`, returning None on revert.
pub fn try_total_supply(&self) -> Option<BigInt> {
self.total_supply().ok()
}

}
